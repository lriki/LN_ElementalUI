//=============================================================================
// LN_ElementalUI.js
// ----------------------------------------------------------------------------
// Copyright (c) 2022 lriki
// This software is released under the MIT License.
// http://opensource.org/licenses/mit-license.php
// ----------------------------------------------------------------------------
// [GitHub] : https://github.com/lriki/LN_ElementalUI
// [Twitter]: https://twitter.com/lriki8
//=============================================================================

/*:ja
 * @target MZ
 * @plugindesc LN_ElementalUI v0.1.0 (MIT License)
 * @author LRIKI
 *
 * @help ユーザーインターフェイスをフルカスタマイズするためのプラグインです。
 *
 * 使い方は次のページを参照してください。
 * https://github.com/lriki/LN_ElementalUI/blob/main/README.md
 *
 * 変更履歴は次のページを参照してください。
 * https://github.com/lriki/LN_ElementalUI/releases
 *
 * 既知の不具合や要望は次のページを参照してください。
 * https://github.com/lriki/LN_ElementalUI/issues
 *
 * @param ThemeName
 * @text テーマ
 * @desc 使用するテーマです。data/ui に入っているフォルダ名を指定してください。
 * @default Default
 * @type string
 *
 * @param ReloadKey
 * @text デザインのリロードキー
 * @desc テストプレイ中にデザインをリロードするためのキーです。
 * @default R
 * @type string
 *
 * @param InfoKey
 * @text ウィンドウ情報の表示キー
 * @desc テストプレイ中にウィンドウ名などの情報を表示するためのキーです。
 * @default T
 * @type string
 */
 
 

 
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./ts/PluginParameters.ts":
/*!********************************!*\
  !*** ./ts/PluginParameters.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.paramInfoKey = exports.paramReloadKey = exports.paramThemeName = void 0;\r\nvar pluginName = 'LN_ElementalUI';\r\nfunction getNumber(key, defaultValue) {\r\n    if (typeof PluginManager == \"undefined\")\r\n        return defaultValue;\r\n    const v = PluginManager.parameters(pluginName)[key];\r\n    if (v === undefined)\r\n        return defaultValue;\r\n    return Number(v);\r\n}\r\nfunction getBoolean(key, defaultValue) {\r\n    if (typeof PluginManager == \"undefined\")\r\n        return defaultValue;\r\n    const v = PluginManager.parameters(pluginName)[key];\r\n    if (v === undefined)\r\n        return defaultValue;\r\n    return v.toLowerCase() === 'true';\r\n}\r\nfunction getString(key, defaultValue) {\r\n    if (typeof PluginManager == \"undefined\")\r\n        return defaultValue;\r\n    const v = PluginManager.parameters(pluginName)[key];\r\n    if (v === undefined)\r\n        return defaultValue;\r\n    return v;\r\n}\r\nexports.paramThemeName = getString(\"ThemeName\", \"Default\");\r\nexports.paramReloadKey = getString(\"ReloadKey\", \"r\").toLowerCase();\r\nexports.paramInfoKey = getString(\"InfoKey\", \"t\").toLowerCase();\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/PluginParameters.ts?");

/***/ }),

/***/ "./ts/animation/AnimationCurve.ts":
/*!****************************************!*\
  !*** ./ts/animation/AnimationCurve.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DKeyFrameAnimationCurve = exports.DKeyFrameTangentMode = exports.DEasingAnimationCurve = exports.DAnimationCurve = exports.DAnimationWrapMode = void 0;\r\nconst Common_1 = __webpack_require__(/*! ts/core/Common */ \"./ts/core/Common.ts\");\r\n/** アニメーションの繰り返し方法 */\r\nvar DAnimationWrapMode;\r\n(function (DAnimationWrapMode) {\r\n    /** 繰り返しを行わず、1度だけ再生します。 */\r\n    DAnimationWrapMode[DAnimationWrapMode[\"Once\"] = 0] = \"Once\";\r\n    /** 最後まで再生された後、先頭に戻ってループします。 */\r\n    DAnimationWrapMode[DAnimationWrapMode[\"Loop\"] = 1] = \"Loop\";\r\n    /** 最後まで再生された後、逆方向に戻ってループします。 */\r\n    DAnimationWrapMode[DAnimationWrapMode[\"Alternate\"] = 2] = \"Alternate\";\r\n})(DAnimationWrapMode = exports.DAnimationWrapMode || (exports.DAnimationWrapMode = {}));\r\nclass DAnimationCurve {\r\n    constructor() {\r\n        this._wrapMode = DAnimationWrapMode.Once;\r\n    }\r\n    /** 指定した時間における値を評価します。*/\r\n    evaluate(time) {\r\n        return this.onEvaluate(this.calculateLocalTime(time, this.lastFrameTime(), this._wrapMode));\r\n    }\r\n    /** アニメーションの終端の時間を取得します。 */\r\n    lastFrameTime() {\r\n        return this.onGetLastFrameTime();\r\n    }\r\n    /** アニメーションの繰り返しの動作を取得します。 */\r\n    wrapMode() {\r\n        return this._wrapMode;\r\n    }\r\n    /** アニメーションの繰り返しの動作を設定します。(default: Once) */\r\n    setWrapMode(mode) {\r\n        this._wrapMode = mode;\r\n    }\r\n    onEvaluate(time) {\r\n        return 0;\r\n    }\r\n    onGetLastFrameTime() {\r\n        return 0;\r\n    }\r\n    calculateLocalTime(time, duration, wrapMode) {\r\n        let localTime = 0.0;\r\n        switch (wrapMode) {\r\n            case DAnimationWrapMode.Once:\r\n                localTime = Math.min(time, duration);\r\n                break;\r\n            case DAnimationWrapMode.Loop:\r\n                localTime = time % duration;\r\n                break;\r\n            case DAnimationWrapMode.Alternate:\r\n                {\r\n                    const freq = duration * 2;\r\n                    const t = (time % freq);\r\n                    const phase = t / freq;\r\n                    if (phase <= 0.5) {\r\n                        localTime = t;\r\n                    }\r\n                    else {\r\n                        localTime = freq - t;\r\n                    }\r\n                    break;\r\n                }\r\n            default:\r\n                throw new Error(\"Unreachable.\");\r\n        }\r\n        return localTime;\r\n    }\r\n}\r\nexports.DAnimationCurve = DAnimationCurve;\r\nclass DEasingAnimationCurve extends DAnimationCurve {\r\n    constructor(startValue, targetValue, duration, func) {\r\n        super();\r\n        this._startValue = startValue;\r\n        this._targetValue = targetValue;\r\n        this._duration = duration;\r\n        this._func = func;\r\n    }\r\n    onEvaluate(time) {\r\n        const t = this._func(time / this._duration);\r\n        return (this._targetValue - this._startValue) * t + this._startValue;\r\n    }\r\n    onGetLastFrameTime() {\r\n        return this._duration;\r\n    }\r\n}\r\nexports.DEasingAnimationCurve = DEasingAnimationCurve;\r\nvar DKeyFrameTangentMode;\r\n(function (DKeyFrameTangentMode) {\r\n    /** 線形補間 */\r\n    DKeyFrameTangentMode[DKeyFrameTangentMode[\"Linear\"] = 0] = \"Linear\";\r\n    /** 接線 (速度) を使用した補間 (エルミートスプライン) */\r\n    DKeyFrameTangentMode[DKeyFrameTangentMode[\"Tangent\"] = 1] = \"Tangent\";\r\n    /** キーフレームの値を通過するなめらかな補間 (Catmull-Rom) */\r\n    DKeyFrameTangentMode[DKeyFrameTangentMode[\"Auto\"] = 2] = \"Auto\";\r\n    /** 補間なし */\r\n    DKeyFrameTangentMode[DKeyFrameTangentMode[\"Constant\"] = 3] = \"Constant\";\r\n})(DKeyFrameTangentMode = exports.DKeyFrameTangentMode || (exports.DKeyFrameTangentMode = {}));\r\nclass DKeyFrameAnimationCurve extends DAnimationCurve {\r\n    constructor() {\r\n        super();\r\n        this._keyFrames = [];\r\n        this._defaultValue = 0.0;\r\n    }\r\n    addKeyFrame(keyFrame) {\r\n        // そのまま追加できる\r\n        if (this._keyFrames.length == 0 || this._keyFrames[this._keyFrames.length - 1].time <= keyFrame.time) {\r\n            this._keyFrames.push(keyFrame);\r\n        }\r\n        // 追加後のソートが必要\r\n        else {\r\n            throw new Error(\"Not implemetend.\");\r\n        }\r\n    }\r\n    addFrame(time, value, rightTangentMode = DKeyFrameTangentMode.Linear, tangent = 0.0) {\r\n        const k = {\r\n            time: time,\r\n            value: value,\r\n            leftTangentMode: DKeyFrameTangentMode.Constant,\r\n            leftTangent: 0.0,\r\n            rightTangentMode: rightTangentMode,\r\n            rightTangent: tangent,\r\n        };\r\n        if (this._keyFrames.length > 0 && this._keyFrames[0].time <= time) {\r\n            const ikey0 = this.findKeyFrameIndex(time);\r\n            (0, Common_1.assert)(ikey0 >= 0);\r\n            const key0 = this._keyFrames[ikey0];\r\n            k.leftTangentMode = key0.rightTangentMode;\r\n            k.leftTangent = -key0.rightTangent;\r\n        }\r\n        else {\r\n            k.leftTangentMode = DKeyFrameTangentMode.Constant;\r\n            k.leftTangent = 0.0;\r\n        }\r\n        this.addKeyFrame(k);\r\n        return this;\r\n    }\r\n    onEvaluate(time) {\r\n        if (this._keyFrames.length == 0) {\r\n            return this._defaultValue;\r\n        }\r\n        // time が最初のフレーム位置より前の場合は Clamp\r\n        if (time < this._keyFrames[0].time) {\r\n            return this._keyFrames[0].value;\r\n        }\r\n        // キーがひとつだけの場合はそのキーの値\r\n        else if (this._keyFrames.length == 1) {\r\n            return this._keyFrames[0].value;\r\n        }\r\n        // time が終端以降の場合は終端の値\r\n        else if (time >= this._keyFrames[this._keyFrames.length - 1].time) {\r\n            return this._keyFrames[this._keyFrames.length - 1].value;\r\n        }\r\n        // 以上以外の場合は補間する\r\n        else {\r\n            const ikey0 = this.findKeyFrameIndex(time);\r\n            const key0 = this._keyFrames[ikey0];\r\n            const key1 = this._keyFrames[ikey0 + 1];\r\n            const p0 = key0.value;\r\n            const p1 = key1.value;\r\n            const t0 = (key0.time);\r\n            const t1 = (key1.time);\r\n            const t = (time - t0) / (t1 - t0);\r\n            // まず2種類のモードで保管する。最後にそれらを t で線形補間することで、異なる TangentMode を補間する\r\n            const modes = [key0.rightTangentMode, key1.leftTangentMode];\r\n            const values = [0, 0];\r\n            for (let i = 0; i < 2; i++) {\r\n                switch (modes[i]) {\r\n                    // 補間無し\r\n                    case DKeyFrameTangentMode.Constant:\r\n                        {\r\n                            values[i] = p0;\r\n                            break;\r\n                        }\r\n                    // 線形\r\n                    case DKeyFrameTangentMode.Linear:\r\n                        {\r\n                            values[i] = p0 + (p1 - p0) * t;\r\n                            break;\r\n                        }\r\n                    // 三次補間\r\n                    case DKeyFrameTangentMode.Tangent:\r\n                        {\r\n                            values[i] = this.hermite(p0, key0.rightTangent, p1, key1.leftTangent, t);\r\n                            break;\r\n                        }\r\n                    // Catmull-Rom\r\n                    case DKeyFrameTangentMode.Auto:\r\n                        {\r\n                            // ループ再生で time が終端を超えている場合、\r\n                            // この時点でkey の値は ループ開始位置のひとつ前のキーを指している\r\n                            const begin = this._keyFrames[0];\r\n                            const end = this._keyFrames[this._keyFrames.length - 1];\r\n                            // この補間には、begin のひとつ前と end のひとつ後の値が必要。\r\n                            // それぞれが始点、終点の場合はループするように補間する\r\n                            values[i] = this.catmullRom(((key0.time == begin.time) ? end.value : this._keyFrames[ikey0 - 1].value), p0, p1, ((key1.time == end.time) ? begin.value : this._keyFrames[ikey0 + 2].value), t);\r\n                            break;\r\n                        }\r\n                }\r\n            }\r\n            return values[0] + (values[1] - values[0]) * t;\r\n        }\r\n    }\r\n    onGetLastFrameTime() {\r\n        if (this._keyFrames.length == 0)\r\n            return 0.0;\r\n        return this._keyFrames[this._keyFrames.length - 1].time;\r\n    }\r\n    findKeyFrameIndex(time) {\r\n        // TODO: 二分探索\r\n        for (let i = this._keyFrames.length - 1; i >= 0; i--) {\r\n            if (this._keyFrames[i].time <= time) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    hermite(v1, a1, v2, a2, t) {\r\n        const a = 2.0 * (v1 - v2) + (a1 + a2);\r\n        const b = 3.0 * (v2 - v1) - (2.0 * a1) - a2;\r\n        let r = a;\r\n        r *= t;\r\n        r += b;\r\n        r *= t;\r\n        r += a1;\r\n        r *= t;\r\n        return r + v1;\r\n    }\r\n    catmullRom(v1, v2, v3, v4, t) {\r\n        const d1 = (v3 - v1) * 0.5;\r\n        const d2 = (v4 - v2) * 0.5;\r\n        return (2.0 * v2 - 2.0 * v3 + d1 + d2) * t * t * t + (-3.0 * v2 + 3.0 * v3 - 2.0 * d1 - d2) * t * t + d1 * t + v2;\r\n    }\r\n}\r\nexports.DKeyFrameAnimationCurve = DKeyFrameAnimationCurve;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/animation/AnimationCurve.ts?");

/***/ }),

/***/ "./ts/animation/AnimationInstance.ts":
/*!*******************************************!*\
  !*** ./ts/animation/AnimationInstance.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.VAnimationInstance = void 0;\r\nconst AnimationCurve_1 = __webpack_require__(/*! ./AnimationCurve */ \"./ts/animation/AnimationCurve.ts\");\r\nclass VAnimationInstance {\r\n    constructor(/*container: PIXI.Container,*/ key, curve, setter) {\r\n        //this.container = container;\r\n        this.key = key;\r\n        this.curve = curve;\r\n        this.setter = setter;\r\n        this.time = 0;\r\n        //this.timeOffset = 0;\r\n    }\r\n    update(elapsedTime) {\r\n        const oldFinished = this.isFinished();\r\n        this.time += elapsedTime;\r\n        const value = this.curve.evaluate(/*this.timeOffset + */ this.time);\r\n        this.setter(value);\r\n        if (this._then) {\r\n            const afterFinished = this.isFinished();\r\n            if (afterFinished && oldFinished != afterFinished) {\r\n                this._then();\r\n            }\r\n        }\r\n    }\r\n    isFinished() {\r\n        if (this.curve.wrapMode() == AnimationCurve_1.DAnimationWrapMode.Once) {\r\n            return this.time >= this.curve.lastFrameTime();\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    then(func) {\r\n        this._then = func;\r\n    }\r\n}\r\nexports.VAnimationInstance = VAnimationInstance;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/animation/AnimationInstance.ts?");

/***/ }),

/***/ "./ts/animation/AnimationManager.ts":
/*!******************************************!*\
  !*** ./ts/animation/AnimationManager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.VAnimation = void 0;\r\nconst Common_1 = __webpack_require__(/*! ts/core/Common */ \"./ts/core/Common.ts\");\r\nconst AnimationCurve_1 = __webpack_require__(/*! ./AnimationCurve */ \"./ts/animation/AnimationCurve.ts\");\r\nconst AnimationInstance_1 = __webpack_require__(/*! ./AnimationInstance */ \"./ts/animation/AnimationInstance.ts\");\r\nclass VAnimation {\r\n    static start(container, key, curve, setter, timeOffset = 0.0) {\r\n        const instance = new AnimationInstance_1.VAnimationInstance(/*container,*/ key, curve, setter);\r\n        //instance.timeOffset = timeOffset;\r\n        instance.time += timeOffset;\r\n        this.add(container, key, instance);\r\n        return instance;\r\n    }\r\n    /**\r\n     * start に対してこちらは現在値を始点とした相対的なアニメーションを表現するのに使用する。\r\n     */\r\n    static startAt(container, key, start, target, duration, curve, setter, timeOffset = 0.0) {\r\n        const instance = new AnimationInstance_1.VAnimationInstance(/*container,*/ key, new AnimationCurve_1.DEasingAnimationCurve(start, target, duration, curve), setter);\r\n        //instance.timeOffset = timeOffset;\r\n        instance.time += timeOffset;\r\n        this.add(container, key, instance);\r\n        return instance;\r\n    }\r\n    static add(container_, key, instance) {\r\n        const container = container_;\r\n        if (!container._animations_RE) {\r\n            container._animations_RE = [];\r\n        }\r\n        const animations = container._animations_RE;\r\n        (0, Common_1.assert)(animations);\r\n        // 同一 key があればそこへ上書き設定\r\n        for (let i = 0; i < animations.length; i++) {\r\n            if (animations[i].key == key) {\r\n                animations[i] = instance;\r\n                return;\r\n            }\r\n        }\r\n        // 無ければ新しく追加\r\n        animations.push(instance);\r\n        if (!this._containers.includes(container)) {\r\n            this._containers.push(container);\r\n        }\r\n    }\r\n    static stop(container_, key) {\r\n        const container = container_;\r\n        if (container._animations_RE) {\r\n            const animations = container._animations_RE;\r\n            for (let i = animations.length - 1; i >= 0; i--) {\r\n                if (animations[i].key == key) {\r\n                    animations.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static stopAll(container_) {\r\n        const container = container_;\r\n        if (container._animations_RE) {\r\n            container._animations_RE = [];\r\n            // mutableRemoveAll\r\n            {\r\n                for (let i = this.length - 1; i >= 0; i--) {\r\n                    if (this._containers[i] == container) {\r\n                        this._containers.splice(i, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static update() {\r\n        const elapsedTime = 0.016;\r\n        for (const container of this._containers) {\r\n            const animations = container._animations_RE;\r\n            if (animations) {\r\n                for (const instance of animations) {\r\n                    instance.update(elapsedTime);\r\n                }\r\n            }\r\n        }\r\n        this.refresh();\r\n    }\r\n    static refresh() {\r\n        for (let i = this._containers.length - 1; i >= 0; i--) {\r\n            // この container のアニメーションはすべて終了している？\r\n            let allFin = true;\r\n            const animations = this._containers[i]._animations_RE;\r\n            if (animations) {\r\n                // for (const instance of animations) {\r\n                //     if (!instance.isFinished()) {\r\n                //         allFin = false;\r\n                //         break;\r\n                //     }\r\n                // }\r\n                for (let iInst = animations.length - 1; iInst >= 0; iInst--) {\r\n                    if (animations[iInst].isFinished()) {\r\n                        animations.splice(iInst, 1);\r\n                    }\r\n                    else {\r\n                        allFin = false;\r\n                    }\r\n                }\r\n            }\r\n            // 更新対象から取り除く\r\n            if (allFin) {\r\n                this._containers.splice(i, 1);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.VAnimation = VAnimation;\r\n//private static _animations: VAnimationInstance[] = [];\r\nVAnimation._containers = [];\r\n// declare namespace PIXI { \r\n//     interface Container {\r\n//         _animations_RE: (VAnimationInstance[] | undefined);\r\n//     }\r\n// }\r\n// declare global {\r\n//     interface Window {\r\n//         _animationClocks_RE: (VAnimationInstance[] | undefined);\r\n//     }\r\n// }\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/animation/AnimationManager.ts?");

/***/ }),

/***/ "./ts/animation/Easing.ts":
/*!********************************!*\
  !*** ./ts/animation/Easing.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n// https://github.com/streamich/ts-easing\r\n// Unlicense — public domain.\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.easing = void 0;\r\nexports.easing = {\r\n    // No easing, no acceleration\r\n    linear: (t) => t,\r\n    // Accelerates fast, then slows quickly towards end.\r\n    quadratic: (t) => t * (-(t * t) * t + 4 * t * t - 6 * t + 4),\r\n    // Overshoots over 1 and then returns to 1 towards end.\r\n    cubic: (t) => t * (4 * t * t - 9 * t + 6),\r\n    // Overshoots over 1 multiple times - wiggles around 1.\r\n    elastic: (t) => t * (33 * t * t * t * t - 106 * t * t * t + 126 * t * t - 67 * t + 15),\r\n    // Accelerating from zero velocity\r\n    inQuad: (t) => t * t,\r\n    // Decelerating to zero velocity\r\n    outQuad: (t) => t * (2 - t),\r\n    // Acceleration until halfway, then deceleration\r\n    inOutQuad: (t) => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t,\r\n    // Accelerating from zero velocity\r\n    inCubic: (t) => t * t * t,\r\n    // Decelerating to zero velocity\r\n    outCubic: (t) => (--t) * t * t + 1,\r\n    // Acceleration until halfway, then deceleration\r\n    inOutCubic: (t) => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,\r\n    // Accelerating from zero velocity\r\n    inQuart: (t) => t * t * t * t,\r\n    // Decelerating to zero velocity\r\n    outQuart: (t) => 1 - (--t) * t * t * t,\r\n    // Acceleration until halfway, then deceleration\r\n    inOutQuart: (t) => t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t,\r\n    // Accelerating from zero velocity\r\n    inQuint: (t) => t * t * t * t * t,\r\n    // Decelerating to zero velocity\r\n    outQuint: (t) => 1 + (--t) * t * t * t * t,\r\n    // Acceleration until halfway, then deceleration\r\n    inOutQuint: (t) => t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t,\r\n    // Accelerating from zero velocity\r\n    inSine: (t) => -Math.cos(t * (Math.PI / 2)) + 1,\r\n    // Decelerating to zero velocity\r\n    outSine: (t) => Math.sin(t * (Math.PI / 2)),\r\n    // Accelerating until halfway, then decelerating\r\n    inOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,\r\n    // Exponential accelerating from zero velocity\r\n    inExpo: (t) => Math.pow(2, 10 * (t - 1)),\r\n    // Exponential decelerating to zero velocity\r\n    outExpo: (t) => -Math.pow(2, -10 * t) + 1,\r\n    // Exponential accelerating until halfway, then decelerating\r\n    inOutExpo: (t) => {\r\n        t /= .5;\r\n        if (t < 1)\r\n            return Math.pow(2, 10 * (t - 1)) / 2;\r\n        t--;\r\n        return (-Math.pow(2, -10 * t) + 2) / 2;\r\n    },\r\n    // Circular accelerating from zero velocity\r\n    inCirc: (t) => -Math.sqrt(1 - t * t) + 1,\r\n    // Circular decelerating to zero velocity Moves VERY fast at the beginning and\r\n    // then quickly slows down in the middle. This tween can actually be used\r\n    // in continuous transitions where target value changes all the time,\r\n    // because of the very quick start, it hides the jitter between target value changes.\r\n    outCirc: (t) => Math.sqrt(1 - (t = t - 1) * t),\r\n    // Circular acceleration until halfway, then deceleration\r\n    inOutCirc: (t) => {\r\n        t /= .5;\r\n        if (t < 1)\r\n            return -(Math.sqrt(1 - t * t) - 1) / 2;\r\n        t -= 2;\r\n        return (Math.sqrt(1 - t * t) + 1) / 2;\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/animation/Easing.ts?");

/***/ }),

/***/ "./ts/animation/PIXI_Container.ts":
/*!****************************************!*\
  !*** ./ts/animation/PIXI_Container.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst AnimationManager_1 = __webpack_require__(/*! ./AnimationManager */ \"./ts/animation/AnimationManager.ts\");\r\nconst _PIXI_Container_prototype_destroy = PIXI.Container.prototype.destroy;\r\nPIXI.Container.prototype.destroy = function (options) {\r\n    AnimationManager_1.VAnimation.stopAll(this);\r\n    _PIXI_Container_prototype_destroy.call(this, options);\r\n};\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/animation/PIXI_Container.ts?");

/***/ }),

/***/ "./ts/core/Common.ts":
/*!***************************!*\
  !*** ./ts/core/Common.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.assert = void 0;\r\nfunction assert(condition, msg) {\r\n    if (!condition) {\r\n        console.error(\"assert: \" + msg);\r\n        throw new Error(msg);\r\n    }\r\n}\r\nexports.assert = assert;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/core/Common.ts?");

/***/ }),

/***/ "./ts/core/DesignScripEvaluator.ts":
/*!*****************************************!*\
  !*** ./ts/core/DesignScripEvaluator.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.evalDesignScript = void 0;\r\nconst DContentPresenter_1 = __webpack_require__(/*! ts/design/DContentPresenter */ \"./ts/design/DContentPresenter.ts\");\r\nconst DStyle_1 = __webpack_require__(/*! ts/design/DStyle */ \"./ts/design/DStyle.ts\");\r\nconst DTransition_1 = __webpack_require__(/*! ts/design/DTransition */ \"./ts/design/DTransition.ts\");\r\nconst DCommandWindow_1 = __webpack_require__(/*! ts/design/DCommandWindow */ \"./ts/design/DCommandWindow.ts\");\r\nconst SceneDesign_1 = __webpack_require__(/*! ts/design/SceneDesign */ \"./ts/design/SceneDesign.ts\");\r\nconst DWindow_1 = __webpack_require__(/*! ts/design/DWindow */ \"./ts/design/DWindow.ts\");\r\nconst DElement_1 = __webpack_require__(/*! ts/design/DElement */ \"./ts/design/DElement.ts\");\r\nconst DListItem_1 = __webpack_require__(/*! ts/design/DListItem */ \"./ts/design/DListItem.ts\");\r\nconst DCommandItem_1 = __webpack_require__(/*! ts/design/DCommandItem */ \"./ts/design/DCommandItem.ts\");\r\nconst DText_1 = __webpack_require__(/*! ts/design/DText */ \"./ts/design/DText.ts\");\r\nconst DImage_1 = __webpack_require__(/*! ts/design/DImage */ \"./ts/design/DImage.ts\");\r\nconst DIcon_1 = __webpack_require__(/*! ts/design/DIcon */ \"./ts/design/DIcon.ts\");\r\nconst DStackLayout_1 = __webpack_require__(/*! ts/design/layout/DStackLayout */ \"./ts/design/layout/DStackLayout.ts\");\r\nconst DGridLayout_1 = __webpack_require__(/*! ts/design/layout/DGridLayout */ \"./ts/design/layout/DGridLayout.ts\");\r\nconst DAccordionLayout_1 = __webpack_require__(/*! ts/design/layout/DAccordionLayout */ \"./ts/design/layout/DAccordionLayout.ts\");\r\nlet designData = null;\r\n//------------------------------------------------------------------------------\r\n// Core\r\nfunction Design(data) {\r\n    designData = data;\r\n}\r\nfunction UIScene(props) {\r\n    return new SceneDesign_1.SceneDesign(props);\r\n}\r\nfunction UIWindow(props) {\r\n    return new DWindow_1.DWindow(props);\r\n}\r\n//------------------------------------------------------------------------------\r\n// Components\r\nfunction UIText(props) {\r\n    return new DText_1.DText(props);\r\n}\r\nfunction UIImage(props) {\r\n    return new DImage_1.DImage(props);\r\n}\r\nfunction UIIcon(props) {\r\n    return new DIcon_1.DIcon(props);\r\n}\r\n//------------------------------------------------------------------------------\r\n// Layout\r\nfunction UIStackLayout(props) {\r\n    return new DStackLayout_1.DStackLayout(props);\r\n}\r\nfunction UIAccordionLayout(props) {\r\n    return new DAccordionLayout_1.DAccordionLayout(props);\r\n}\r\nfunction UOGridLayout(props) {\r\n    return new DGridLayout_1.DGridLayout(props);\r\n}\r\n//------------------------------------------------------------------------------\r\n// \r\nfunction ContentPresenter(props) {\r\n    return new DContentPresenter_1.DContentPresenter(props);\r\n}\r\nfunction ListItem(props) {\r\n    return new DListItem_1.DListItem(props);\r\n}\r\n// function Picture(props: PictureProps) {\r\n//     return new PictureDef(props);\r\n// }\r\nfunction Style(props) {\r\n    return new DStyle_1.DStyle(props);\r\n}\r\n// function EasingAnimation(props: EasingAnimationProps) {\r\n//     return props;\r\n// }\r\nfunction Part(props) {\r\n    return new DElement_1.DPart(props);\r\n    //return FlexWindowsManager.instance.clonePartElement(props);\r\n}\r\nfunction Transition(props) {\r\n    return new DTransition_1.DTransition(props);\r\n    //return FlexWindowsManager.instance.clonePartElement(props);\r\n}\r\nfunction Script(script) {\r\n    return new DStyle_1.DStyleScriptValue(script);\r\n}\r\nfunction CommandWindow(props) {\r\n    return new DCommandWindow_1.DCommandWindow(props);\r\n}\r\nfunction CommandItem(props) {\r\n    return new DCommandItem_1.DCommandItem(props);\r\n}\r\nfunction evalDesignScript(code) {\r\n    eval(code);\r\n    return designData;\r\n    // var result = null;\r\n    // var script = new Function(\"context\", code);\r\n    // try {\r\n    //     result = script(context);\r\n    // } catch (e) {\r\n    //     console.log(e);\r\n    // }\r\n    // return result;\r\n}\r\nexports.evalDesignScript = evalDesignScript;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/core/DesignScripEvaluator.ts?");

/***/ }),

/***/ "./ts/core/FlexWindowsManager.ts":
/*!***************************************!*\
  !*** ./ts/core/FlexWindowsManager.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FlexWindowsManager = exports.PictureDef = void 0;\r\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\r\nconst UIElementFactory_1 = __webpack_require__(/*! ts/ui/UIElementFactory */ \"./ts/ui/UIElementFactory.ts\");\r\nconst SceneDesign_1 = __webpack_require__(/*! ../design/SceneDesign */ \"./ts/design/SceneDesign.ts\");\r\nconst WindowBuilder_1 = __webpack_require__(/*! ./WindowBuilder */ \"./ts/core/WindowBuilder.ts\");\r\nconst DWindow_1 = __webpack_require__(/*! ../design/DWindow */ \"./ts/design/DWindow.ts\");\r\nconst Common_1 = __webpack_require__(/*! ./Common */ \"./ts/core/Common.ts\");\r\nconst DesignScripEvaluator_1 = __webpack_require__(/*! ./DesignScripEvaluator */ \"./ts/core/DesignScripEvaluator.ts\");\r\nconst PluginParameters_1 = __webpack_require__(/*! ts/PluginParameters */ \"./ts/PluginParameters.ts\");\r\nclass PictureDef {\r\n    constructor(props) {\r\n        this.props = props;\r\n    }\r\n}\r\nexports.PictureDef = PictureDef;\r\nclass FlexWindowsManager {\r\n    constructor() {\r\n        this.displayWindowInfo = false;\r\n        this._sceneDesigns = new Map();\r\n        this._windowDesigns = new Map();\r\n        this._loadedFileCount = 0;\r\n        this._settingFiles = [];\r\n        this._designFilesRevision = 1;\r\n        this._isReady = false;\r\n        this._windowBuilder = new WindowBuilder_1.WindowBuilder();\r\n        this._uiElementFactory = new UIElementFactory_1.UIElementFactory();\r\n    }\r\n    initialize() {\r\n        this.updateIndexFile();\r\n        this.beginLoadDesignFiles();\r\n    }\r\n    get isReady() {\r\n        return this._isReady;\r\n    }\r\n    get designFilesRevision() {\r\n        return this._designFilesRevision;\r\n    }\r\n    get sceneDesigns() {\r\n        return this._sceneDesigns;\r\n    }\r\n    get windowDesigns() {\r\n        return this._windowDesigns;\r\n    }\r\n    get windowBuilder() {\r\n        return this._windowBuilder;\r\n    }\r\n    get uiElementFactory() {\r\n        return this._uiElementFactory;\r\n    }\r\n    get designDirectory() {\r\n        return `data/ui/${PluginParameters_1.paramThemeName}/`;\r\n    }\r\n    registerElementComponent() {\r\n    }\r\n    registerValueComponent() {\r\n    }\r\n    findSceneDesign(window) {\r\n        const className = window.constructor.name;\r\n        return this._sceneDesigns.get(className);\r\n    }\r\n    findWindowDesign(window) {\r\n        const className = window.constructor.name;\r\n        return this._windowDesigns.get(className);\r\n    }\r\n    clonePartElement(props) {\r\n        const className = props.class;\r\n        const design = this._windowDesigns.get(className);\r\n        (0, Common_1.assert)(design);\r\n        const newDesign = design.clone();\r\n        newDesign.mergeProps(props);\r\n        return newDesign;\r\n    }\r\n    reloadSceneDesignIfNeeded(rmmzScene) {\r\n        if (rmmzScene._flexDesignRevision === this.designFilesRevision)\r\n            return;\r\n        rmmzScene._flexDesignRevision = this.designFilesRevision;\r\n        let attachedExistingWindows = [];\r\n        if (rmmzScene._flexUIScene) {\r\n            attachedExistingWindows = [...rmmzScene._flexUIScene.attachedExistingWindows];\r\n            this.unloadSceneDesignIfNeeded(rmmzScene);\r\n        }\r\n        rmmzScene._flexUIScene = undefined;\r\n        const design = this.findSceneDesign(rmmzScene);\r\n        //if (design) {\r\n        rmmzScene._flexUIScene = this.uiElementFactory.instantiateScene(design);\r\n        rmmzScene._flexUIScene.attachRmmzScene(rmmzScene);\r\n        rmmzScene._flexUIScene.context.layoutInitial(Graphics.boxWidth, Graphics.boxHeight);\r\n        // attachedExistingWindows が存在するということは、デザインのリロードが行われたということ。\r\n        if (attachedExistingWindows.length > 0) {\r\n            for (const rmmzWindow of attachedExistingWindows) {\r\n                rmmzScene._flexUIScene.attachRmmzWindowIfNeeded(rmmzWindow);\r\n            }\r\n            ;\r\n            rmmzScene._flexUIScene.onSceneCreate();\r\n        }\r\n        //}\r\n    }\r\n    unloadSceneDesignIfNeeded(rmmzScene) {\r\n        if (rmmzScene._flexUIScene) {\r\n            rmmzScene._flexUIScene.detachRmmzScene();\r\n            rmmzScene._flexUIScene = undefined;\r\n        }\r\n    }\r\n    /** 既に存在している Window に対して、テンプレートを適用する */\r\n    // public applyDesign(window: Window_Base): void {\r\n    //     const className = window.constructor.name;\r\n    //     const data = this._windowDesigns.get(className);\r\n    //     if (data) {\r\n    //         this._windowBuilder.applyDesign(window, data);\r\n    //     }\r\n    // }\r\n    // private loadWindowTemplate(className: string): WindowTemplate {\r\n    //     const data = this._windowTemplates.get(className);\r\n    //     if (data) {\r\n    //         return data;\r\n    //     }\r\n    //     else {\r\n    //     }\r\n    // }\r\n    reloadDesigns() {\r\n        this.beginLoadDesignFiles();\r\n    }\r\n    updateIndexFile() {\r\n        if (this.isNode()) {\r\n            const allFiles = fs_1.default.readdirSync(this.designDirectory);\r\n            const settingFiles = allFiles.filter((file) => file.endsWith(\".js\"));\r\n            const indexData = settingFiles;\r\n            fs_1.default.writeFileSync(this.designDirectory + \"/index.json\", JSON.stringify(indexData));\r\n        }\r\n        else {\r\n        }\r\n    }\r\n    beginLoadDesignFiles() {\r\n        this.loadDataFile(this.designDirectory + \"/index.json\", (obj) => {\r\n            this._settingFiles = obj;\r\n            this._loadedFileCount = 0;\r\n            for (let i = 0; i < this._settingFiles.length; i++) {\r\n                const file = this._settingFiles[i];\r\n                if (file) {\r\n                    this.loadTextFile(this.designDirectory + \"/\" + file, (str) => {\r\n                        this.evalSetting(str);\r\n                        this._loadedFileCount++;\r\n                        if (this._loadedFileCount >= this._settingFiles.length) {\r\n                            this.buildDesigns();\r\n                            this._isReady = true;\r\n                            this._designFilesRevision++;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n    evalSetting(str) {\r\n        const data = (0, DesignScripEvaluator_1.evalDesignScript)(str);\r\n        if (data instanceof SceneDesign_1.SceneDesign) {\r\n            this._sceneDesigns.set(data.class, data);\r\n        }\r\n        else if (data instanceof DWindow_1.DWindow) {\r\n            this._windowDesigns.set(data.props.class, data);\r\n        }\r\n    }\r\n    buildDesigns() {\r\n        this._windowDesigns.forEach((value, key) => {\r\n            value.link(this);\r\n        });\r\n        this._sceneDesigns.forEach((value, key) => {\r\n            value.link(this);\r\n        });\r\n    }\r\n    loadDataFile(src, onLoad) {\r\n        if (this.isNode()) {\r\n            const data = JSON.parse(fs_1.default.readFileSync(src).toString());\r\n            onLoad(data);\r\n        }\r\n        else {\r\n            const xhr = new XMLHttpRequest();\r\n            const url = src;\r\n            xhr.open(\"GET\", url);\r\n            xhr.overrideMimeType(\"application/json\");\r\n            xhr.onload = () => this.onXhrLoad(xhr, src, url, (obj) => { onLoad(obj); });\r\n            xhr.onerror = () => DataManager.onXhrError(src, src, url);\r\n            xhr.send();\r\n        }\r\n    }\r\n    loadTextFile(src, onLoad) {\r\n        if (this.isNode()) {\r\n            onLoad(fs_1.default.readFileSync(src).toString());\r\n        }\r\n        else {\r\n            throw new Error(\"Not implemented.\");\r\n        }\r\n    }\r\n    // private loadXmlFile(src: string, onLoad: (obj: any) => void) {\r\n    //     if (this.isNode()) {\r\n    //         const dataDir = \"data/\";\r\n    //         const xmlString = fs.readFileSync(dataDir + src).toString();\r\n    //         const jsdom = new JSDOM();\r\n    //         const parser = new jsdom.window.DOMParser();\r\n    //         const dom = parser.parseFromString(xmlString, \"application/xml\");\r\n    //         onLoad(dom);\r\n    //     }\r\n    //     else {\r\n    //         // const xhr = new XMLHttpRequest();\r\n    //         // const url = \"data/\" + src;\r\n    //         // xhr.open(\"GET\", url);\r\n    //         // xhr.overrideMimeType(\"text/xml\");\r\n    //         // xhr.onload = () => onLoad(xhr, src, url, (obj) => { onLoad(obj); });\r\n    //         // xhr.onerror = () => DataManager.onXhrError(src, src, url);\r\n    //         // xhr.send();\r\n    //     }\r\n    // }\r\n    isNode() {\r\n        return (process.title !== 'browser');\r\n    }\r\n    isPlaytest() {\r\n        return $gameTemp && $gameTemp.isPlaytest();\r\n    }\r\n    onXhrLoad(xhr, src, url, onLoad) {\r\n        if (xhr.status < 400) {\r\n            onLoad(JSON.parse(xhr.responseText));\r\n        }\r\n        else {\r\n            DataManager.onXhrError(src, src, url);\r\n        }\r\n    }\r\n}\r\nexports.FlexWindowsManager = FlexWindowsManager;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/core/FlexWindowsManager.ts?");

/***/ }),

/***/ "./ts/core/WindowBuilder.ts":
/*!**********************************!*\
  !*** ./ts/core/WindowBuilder.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.WindowBuilder = void 0;\r\nconst DListItem_1 = __webpack_require__(/*! ts/design/DListItem */ \"./ts/design/DListItem.ts\");\r\nconst UIListItem_1 = __webpack_require__(/*! ts/ui/components/UIListItem */ \"./ts/ui/components/UIListItem.ts\");\r\nconst Common_1 = __webpack_require__(/*! ./Common */ \"./ts/core/Common.ts\");\r\nconst FlexWindowsManager_1 = __webpack_require__(/*! ./FlexWindowsManager */ \"./ts/core/FlexWindowsManager.ts\");\r\nclass WindowBuilder {\r\n    // public applyDesign(window: Window_Base, design: DWindow) {\r\n    //     const rect = design.props.rect;\r\n    //     if (rect) {\r\n    //         if (rect[0] !== undefined) window.x = rect[0];\r\n    //         if (rect[1] !== undefined) window.y = rect[1];\r\n    //         if (rect[2] !== undefined) window.width = rect[2];\r\n    //         if (rect[3] !== undefined) window.height = rect[3];\r\n    //     }\r\n    //     window._flexWindowDesignRevision = design.revision;\r\n    //     // (window as any).itemLineRect = function(index: number) {\r\n    //     //     console.log(\"itemLineRect !!!!\");\r\n    //     //     return new Rectangle(0, 0, 100, 100);\r\n    //     // }\r\n    // }\r\n    applyCommandListContents(rmmzWindow, design, baseMakeList) {\r\n        const manager = FlexWindowsManager_1.FlexWindowsManager.instance;\r\n        const window = rmmzWindow._flexUIWindow;\r\n        (0, Common_1.assert)(window);\r\n        let index = 0;\r\n        const contents = design.props.contents || [];\r\n        // for (; index < children.length; index++) {\r\n        //     const element = children[index];\r\n        //     if (element instanceof DListItem) {\r\n        //         window.addCommand(element.text, element.symbol, element.enable, undefined);\r\n        //     }\r\n        // }\r\n        // ItemPresenter\r\n        {\r\n            let firstOriginalIndex = rmmzWindow._list.length;\r\n            baseMakeList();\r\n            // 元の makeCommandList() によって追加されたアイテムの分の UIElement を作成する。\r\n            for (let i = firstOriginalIndex; i < rmmzWindow._list.length; i++) {\r\n                const command = rmmzWindow._list[i];\r\n                const element = new DListItem_1.DListItem({\r\n                    text: command.name,\r\n                    symbol: command.symbol,\r\n                    enabled: command.enabled,\r\n                });\r\n                const uielement = new UIListItem_1.UIListItem(element);\r\n                uielement.rmmzCommandIndex = i;\r\n                window.addLogicalChild(uielement);\r\n            }\r\n        }\r\n        // ItemPresenter の後\r\n        for (; index < contents.length; index++) {\r\n            const element = contents[index];\r\n            if (element instanceof DListItem_1.DListItem) {\r\n                const uielement = new UIListItem_1.UIListItem(element);\r\n                uielement.rmmzCommandIndex = rmmzWindow._list.length;\r\n                window.addLogicalChild(uielement);\r\n                rmmzWindow.addCommand(element.text, element.symbol, element.enabled, undefined);\r\n            }\r\n        }\r\n        // Item template\r\n        {\r\n        }\r\n    }\r\n    // public makeRect(design: DWindow, src: Rectangle): Rectangle {\r\n    //     const rect = design.props.rect;\r\n    //     if (rect) {\r\n    //         const newRect = new Rectangle(src.x, src.y, src.width, src.height);\r\n    //         if (rect[0] !== undefined) newRect.x = rect[0];\r\n    //         if (rect[1] !== undefined) newRect.y = rect[1];\r\n    //         if (rect[2] !== undefined) newRect.width = rect[2];\r\n    //         if (rect[3] !== undefined) newRect.height = rect[3];\r\n    //         return newRect;\r\n    //     }\r\n    //     else {\r\n    //         return src;\r\n    //     }\r\n    // }\r\n    applyElement(window, element) {\r\n        console.log(\"a\");\r\n        if (element instanceof DListItem_1.DListItem) {\r\n            console.log(\"a1\");\r\n            if (window instanceof Window_Command) {\r\n                console.log(\"a2\", element);\r\n                window.addCommand(element.text, element.symbol, element.enabled, undefined);\r\n                window.refresh();\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.WindowBuilder = WindowBuilder;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/core/WindowBuilder.ts?");

/***/ }),

/***/ "./ts/design/DCommandItem.ts":
/*!***********************************!*\
  !*** ./ts/design/DCommandItem.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DCommandItem = void 0;\r\nconst DSelectableItem_1 = __webpack_require__(/*! ./DSelectableItem */ \"./ts/design/DSelectableItem.ts\");\r\n/**\r\n */\r\nclass DCommandItem extends DSelectableItem_1.DSelectableItem {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n    clone() {\r\n        return new DCommandItem(Object.assign({}, this.props));\r\n    }\r\n}\r\nexports.DCommandItem = DCommandItem;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DCommandItem.ts?");

/***/ }),

/***/ "./ts/design/DCommandWindow.ts":
/*!*************************************!*\
  !*** ./ts/design/DCommandWindow.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DCommandWindow = void 0;\r\nconst DWindow_1 = __webpack_require__(/*! ./DWindow */ \"./ts/design/DWindow.ts\");\r\n/**\r\n */\r\nclass DCommandWindow extends DWindow_1.DWindow {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n    clone() {\r\n        return new DCommandWindow(Object.assign({}, this.props));\r\n    }\r\n}\r\nexports.DCommandWindow = DCommandWindow;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DCommandWindow.ts?");

/***/ }),

/***/ "./ts/design/DContentPresenter.ts":
/*!****************************************!*\
  !*** ./ts/design/DContentPresenter.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DContentPresenter = void 0;\r\nconst DElement_1 = __webpack_require__(/*! ./DElement */ \"./ts/design/DElement.ts\");\r\nclass DContentPresenter extends DElement_1.DElement {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n}\r\nexports.DContentPresenter = DContentPresenter;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DContentPresenter.ts?");

/***/ }),

/***/ "./ts/design/DElement.ts":
/*!*******************************!*\
  !*** ./ts/design/DElement.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DPart = exports.DElement = exports.DAlignment = void 0;\r\nconst Common_1 = __webpack_require__(/*! ts/core/Common */ \"./ts/core/Common.ts\");\r\nconst DStyle_1 = __webpack_require__(/*! ./DStyle */ \"./ts/design/DStyle.ts\");\r\nvar DAlignment;\r\n(function (DAlignment) {\r\n    /** 子要素を、親のレイアウト スロットの中央に揃えて配置します。*/\r\n    DAlignment[\"Center\"] = \"center\";\r\n    /** 子要素を、親のレイアウト スロットの左側に揃えて配置します。*/\r\n    DAlignment[\"Left\"] = \"left\";\r\n    /** 子要素を、親のレイアウト スロットの上端に揃えて配置します。*/\r\n    DAlignment[\"Top\"] = \"top\";\r\n    /** 子要素を、親のレイアウト スロットの右側に揃えて配置します。*/\r\n    DAlignment[\"Right\"] = \"right\";\r\n    /** 子要素を、親のレイアウト スロットの下端に揃えて配置します。*/\r\n    DAlignment[\"Bottom\"] = \"bottom\";\r\n    /** 子要素を、親のレイアウト スロットの左上に揃えて配置します。*/\r\n    DAlignment[\"TopLeft\"] = \"top-left\";\r\n    /** 子要素を、親のレイアウト スロットの右上に揃えて配置します。*/\r\n    DAlignment[\"TopRight\"] = \"top-right\";\r\n    /** 子要素を、親のレイアウト スロットの左下に揃えて配置します。*/\r\n    DAlignment[\"BottomLeft\"] = \"bottom-left\";\r\n    /** 子要素を、親のレイアウト スロットの右下に揃えて配置します。*/\r\n    DAlignment[\"BottomRight\"] = \"bottom-right\";\r\n    /** 子要素を、親のレイアウト スロットの左側に揃え、上下を引き延ばして配置します。*/\r\n    DAlignment[\"LeftStretch\"] = \"left-stretch\";\r\n    /** 子要素を、親のレイアウト スロットの上側に揃え、左右を引き延ばして配置します。*/\r\n    DAlignment[\"TopStretch\"] = \"top-stretch\";\r\n    /** 子要素を、親のレイアウト スロットの右側に揃え、上下を引き延ばして配置します。*/\r\n    DAlignment[\"RightStretch\"] = \"right-stretch\";\r\n    /** 子要素を、親のレイアウト スロットの下側に揃え、左右を引き延ばして配置します。*/\r\n    DAlignment[\"BottomStretch\"] = \"bottom-stretch\";\r\n    /** 子要素を、親のレイアウト スロットの中央に揃え、左右を引き延ばして配置します。*/\r\n    DAlignment[\"HorizontalStretch\"] = \"horizontal-stretch\";\r\n    /** 子要素を、親のレイアウト スロットの中央に揃え、上下を引き延ばして配置します。*/\r\n    DAlignment[\"VerticalStretch\"] = \"vertical-stretch\";\r\n    /** 子要素を、親のレイアウト スロット全体に引き伸ばします。*/\r\n    DAlignment[\"Stretch\"] = \"stretch\";\r\n})(DAlignment = exports.DAlignment || (exports.DAlignment = {}));\r\nclass DElement {\r\n    constructor(props) {\r\n        this.props = props;\r\n        this._defaultStyle = new DStyle_1.DStyle(this.props);\r\n    }\r\n    get defaultStyle() {\r\n        return this._defaultStyle;\r\n    }\r\n    clone() {\r\n        return new DElement(Object.assign({}, this.props));\r\n    }\r\n    mergeProps(base) {\r\n        const result = Object.assign(Object.assign({}, base), this.props);\r\n        this.props = result;\r\n        this._defaultStyle = new DStyle_1.DStyle(this.props);\r\n    }\r\n    // public get alignment(): DAlignment {\r\n    //     return this.alignment ?? DAlignment.Center;\r\n    // }\r\n    get contents() {\r\n        var _a;\r\n        return (_a = this.props.contents) !== null && _a !== void 0 ? _a : [];\r\n    }\r\n    get transitions() {\r\n        var _a;\r\n        return (_a = this.props.transitions) !== null && _a !== void 0 ? _a : [];\r\n    }\r\n    findElementByClass(className) {\r\n        if (this.props.class === className) {\r\n            return this;\r\n        }\r\n        for (const child of this.contents) {\r\n            const result = child.findElementByClass(className);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    findStyle(stateName) {\r\n        const styles = this.props.styles;\r\n        if (styles) {\r\n            for (const style of styles) {\r\n                if (style.props.state === stateName) {\r\n                    return style;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    link(manager) {\r\n        const contents = this.props.contents;\r\n        if (contents) {\r\n            for (let i = 0; i < this.contents.length; i++) {\r\n                let child = contents[i];\r\n                if (child instanceof DPart) {\r\n                    child = manager.clonePartElement(child.props);\r\n                    contents[i] = child;\r\n                }\r\n                child.link(manager);\r\n            }\r\n        }\r\n        for (const child of this.contents) {\r\n            child.link(manager);\r\n        }\r\n        // if (this.props.windowskin) {\r\n        //     this.props.windowskin = manager.designDirectory + \"/\" + this.props.windowskin;\r\n        // }\r\n    }\r\n}\r\nexports.DElement = DElement;\r\n/**\r\n * Desing 初期構築用のダミーデータ。\r\n * link で本来あるべきデータに置き換えられる。\r\n */\r\nclass DPart extends DElement {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n    get target() {\r\n        (0, Common_1.assert)(this._target);\r\n        return this._target;\r\n    }\r\n}\r\nexports.DPart = DPart;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DElement.ts?");

/***/ }),

/***/ "./ts/design/DIcon.ts":
/*!****************************!*\
  !*** ./ts/design/DIcon.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DIcon = void 0;\r\nconst DElement_1 = __webpack_require__(/*! ./DElement */ \"./ts/design/DElement.ts\");\r\nclass DIcon extends DElement_1.DElement {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n    get iconIndex() {\r\n        var _a;\r\n        return (_a = this.props.iconIndex) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n}\r\nexports.DIcon = DIcon;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DIcon.ts?");

/***/ }),

/***/ "./ts/design/DImage.ts":
/*!*****************************!*\
  !*** ./ts/design/DImage.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DImage = void 0;\r\nconst DElement_1 = __webpack_require__(/*! ./DElement */ \"./ts/design/DElement.ts\");\r\nclass DImage extends DElement_1.DElement {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n    get source() {\r\n        var _a;\r\n        return (_a = this.props.source) !== null && _a !== void 0 ? _a : \"ElementalUI/BadImage\";\r\n    }\r\n}\r\nexports.DImage = DImage;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DImage.ts?");

/***/ }),

/***/ "./ts/design/DListItem.ts":
/*!********************************!*\
  !*** ./ts/design/DListItem.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DListItem = void 0;\r\nconst DElement_1 = __webpack_require__(/*! ./DElement */ \"./ts/design/DElement.ts\");\r\nclass DListItem extends DElement_1.DElement {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n    get text() {\r\n        var _a;\r\n        return (_a = this.props.text) !== null && _a !== void 0 ? _a : \"\";\r\n    }\r\n    get symbol() {\r\n        var _a;\r\n        return (_a = this.props.symbol) !== null && _a !== void 0 ? _a : \"\";\r\n    }\r\n    get enabled() {\r\n        var _a;\r\n        return (_a = this.props.enabled) !== null && _a !== void 0 ? _a : true;\r\n    }\r\n}\r\nexports.DListItem = DListItem;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DListItem.ts?");

/***/ }),

/***/ "./ts/design/DSelectableItem.ts":
/*!**************************************!*\
  !*** ./ts/design/DSelectableItem.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DSelectableItem = void 0;\r\nconst DElement_1 = __webpack_require__(/*! ./DElement */ \"./ts/design/DElement.ts\");\r\n/**\r\n */\r\nclass DSelectableItem extends DElement_1.DElement {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n    clone() {\r\n        return new DSelectableItem(Object.assign({}, this.props));\r\n    }\r\n}\r\nexports.DSelectableItem = DSelectableItem;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DSelectableItem.ts?");

/***/ }),

/***/ "./ts/design/DStyle.ts":
/*!*****************************!*\
  !*** ./ts/design/DStyle.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DStyle = exports.DStyleScriptValue = void 0;\r\nclass DStyleScriptValue {\r\n    constructor(script) {\r\n        this.script = script;\r\n    }\r\n}\r\nexports.DStyleScriptValue = DStyleScriptValue;\r\nclass DStyle {\r\n    constructor(props) {\r\n        this.props = props;\r\n        if (this.props.left !== undefined)\r\n            this.props.marginLeft = this.props.left;\r\n        if (this.props.top !== undefined)\r\n            this.props.marginTop = this.props.top;\r\n        if (this.props.right !== undefined)\r\n            this.props.marginRight = this.props.right;\r\n        if (this.props.bottom !== undefined)\r\n            this.props.marginBottom = this.props.bottom;\r\n    }\r\n}\r\nexports.DStyle = DStyle;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DStyle.ts?");

/***/ }),

/***/ "./ts/design/DText.ts":
/*!****************************!*\
  !*** ./ts/design/DText.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DText = void 0;\r\nconst DElement_1 = __webpack_require__(/*! ./DElement */ \"./ts/design/DElement.ts\");\r\nclass DText extends DElement_1.DElement {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n}\r\nexports.DText = DText;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DText.ts?");

/***/ }),

/***/ "./ts/design/DTransition.ts":
/*!**********************************!*\
  !*** ./ts/design/DTransition.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DTransition = void 0;\r\n/**\r\n * 指定プロパティの変更に応じてアニメーションを起動する。\r\n * CSS の transition に似ている。\r\n * Style とは独立したもので、プロパティに付属する情報である。\r\n */\r\nclass DTransition {\r\n    constructor(props) {\r\n        this.props = props;\r\n    }\r\n    get property() {\r\n        var _a;\r\n        return (_a = this.props.property) !== null && _a !== void 0 ? _a : \"\";\r\n    }\r\n    get duration() {\r\n        var _a;\r\n        return (_a = this.props.duration) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    get delay() {\r\n        var _a;\r\n        return (_a = this.props.delay) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n}\r\nexports.DTransition = DTransition;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DTransition.ts?");

/***/ }),

/***/ "./ts/design/DWindow.ts":
/*!******************************!*\
  !*** ./ts/design/DWindow.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DWindow = void 0;\r\nconst DElement_1 = __webpack_require__(/*! ts/design/DElement */ \"./ts/design/DElement.ts\");\r\n/**\r\n * 各種 Window のデザインデータ\r\n *\r\n * Window が new されたとき (initialize() されたとき) に、このデザインを適用する。\r\n */\r\nclass DWindow extends DElement_1.DElement {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n        this.revision = 1;\r\n    }\r\n    clone() {\r\n        return new DWindow(Object.assign({}, this.props));\r\n    }\r\n}\r\nexports.DWindow = DWindow;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/DWindow.ts?");

/***/ }),

/***/ "./ts/design/SceneDesign.ts":
/*!**********************************!*\
  !*** ./ts/design/SceneDesign.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SceneDesign = void 0;\r\nconst DElement_1 = __webpack_require__(/*! ./DElement */ \"./ts/design/DElement.ts\");\r\n/**\r\n *\r\n */\r\nclass SceneDesign extends DElement_1.DElement {\r\n    //public revision: number;\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n        //this.revision = 1;\r\n    }\r\n    get class() {\r\n        return this.props.class || \"\";\r\n    }\r\n}\r\nexports.SceneDesign = SceneDesign;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/SceneDesign.ts?");

/***/ }),

/***/ "./ts/design/layout/DAccordionLayout.ts":
/*!**********************************************!*\
  !*** ./ts/design/layout/DAccordionLayout.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DAccordionLayout = void 0;\r\nconst DElement_1 = __webpack_require__(/*! ../DElement */ \"./ts/design/DElement.ts\");\r\nconst DStackLayout_1 = __webpack_require__(/*! ./DStackLayout */ \"./ts/design/layout/DStackLayout.ts\");\r\nclass DAccordionLayout extends DElement_1.DElement {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n    get orientation() {\r\n        return this.props.orientation || DStackLayout_1.DOrientation.Horizontal;\r\n    }\r\n}\r\nexports.DAccordionLayout = DAccordionLayout;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/layout/DAccordionLayout.ts?");

/***/ }),

/***/ "./ts/design/layout/DGridLayout.ts":
/*!*****************************************!*\
  !*** ./ts/design/layout/DGridLayout.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DGridLayout = void 0;\r\nconst DElement_1 = __webpack_require__(/*! ../DElement */ \"./ts/design/DElement.ts\");\r\nclass DGridLayout extends DElement_1.DElement {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n}\r\nexports.DGridLayout = DGridLayout;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/layout/DGridLayout.ts?");

/***/ }),

/***/ "./ts/design/layout/DStackLayout.ts":
/*!******************************************!*\
  !*** ./ts/design/layout/DStackLayout.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DStackLayout = exports.DOrientation = void 0;\r\nconst DElement_1 = __webpack_require__(/*! ../DElement */ \"./ts/design/DElement.ts\");\r\nvar DOrientation;\r\n(function (DOrientation) {\r\n    DOrientation[\"Horizontal\"] = \"horizontal\";\r\n    DOrientation[\"Vertical\"] = \"vertical\";\r\n    DOrientation[\"ReverseHorizontal\"] = \"reverse-horizontal\";\r\n    DOrientation[\"ReverseVertical\"] = \"reverse-vertical\";\r\n})(DOrientation = exports.DOrientation || (exports.DOrientation = {}));\r\nclass DStackLayout extends DElement_1.DElement {\r\n    constructor(props) {\r\n        super(props);\r\n        this.props = props;\r\n    }\r\n    get orientation() {\r\n        return this.props.orientation || DOrientation.Horizontal;\r\n    }\r\n}\r\nexports.DStackLayout = DStackLayout;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/design/layout/DStackLayout.ts?");

/***/ }),

/***/ "./ts/index.ts":
/*!*********************!*\
  !*** ./ts/index.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__webpack_require__(/*! ./PluginParameters */ \"./ts/PluginParameters.ts\");\r\n__webpack_require__(/*! ./core/FlexWindowsManager */ \"./ts/core/FlexWindowsManager.ts\");\r\n__webpack_require__(/*! ./animation/PIXI_Container */ \"./ts/animation/PIXI_Container.ts\");\r\n__webpack_require__(/*! ./rmmz/SceneManager */ \"./ts/rmmz/SceneManager.ts\");\r\n__webpack_require__(/*! ./rmmz/PluginManager */ \"./ts/rmmz/PluginManager.ts\");\r\n// import \"./rmmz/PluginParameters\"\r\n__webpack_require__(/*! ./rmmz/Input */ \"./ts/rmmz/Input.ts\");\r\n// import \"./rmmz/TouchInput\"\r\n// import \"./rmmz/DataManager\"\r\n// import \"./rmmz/Game_Screen\"\r\n// import \"./rmmz/Game_Map\"\r\n// import \"./rmmz/PluginCommands\"\r\n// import \"./rmmz/Sprite_Animation\"\r\n// import \"./rmmz/Spriteset_Map\"\r\n// import \"./rmmz/Spriteset_Battle\"\r\n__webpack_require__(/*! ./rmmz/Scene_Base */ \"./ts/rmmz/Scene_Base.ts\");\r\n__webpack_require__(/*! ./rmmz/Scene_Boot */ \"./ts/rmmz/Scene_Boot.ts\");\r\n__webpack_require__(/*! ./rmmz/Window_Base */ \"./ts/rmmz/Window_Base.ts\");\r\n__webpack_require__(/*! ./rmmz/Window_Command */ \"./ts/rmmz/Window_Command.ts\");\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/index.ts?");

/***/ }),

/***/ "./ts/rmmz/Input.ts":
/*!**************************!*\
  !*** ./ts/rmmz/Input.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst FlexWindowsManager_1 = __webpack_require__(/*! ts/core/FlexWindowsManager */ \"./ts/core/FlexWindowsManager.ts\");\r\nconst PluginParameters_1 = __webpack_require__(/*! ts/PluginParameters */ \"./ts/PluginParameters.ts\");\r\nconst _Input_onKeyDown = Input._onKeyDown;\r\nInput._onKeyDown = function (event) {\r\n    if (!FlexWindowsManager_1.FlexWindowsManager.instance ||\r\n        !FlexWindowsManager_1.FlexWindowsManager.instance.isReady ||\r\n        !FlexWindowsManager_1.FlexWindowsManager.instance.isPlaytest()) {\r\n        return _Input_onKeyDown.call(this, event);\r\n    }\r\n    if (event.key == PluginParameters_1.paramReloadKey) {\r\n        FlexWindowsManager_1.FlexWindowsManager.instance.reloadDesigns();\r\n    }\r\n    else if (event.key == PluginParameters_1.paramInfoKey) {\r\n        FlexWindowsManager_1.FlexWindowsManager.instance.displayWindowInfo = !FlexWindowsManager_1.FlexWindowsManager.instance.displayWindowInfo;\r\n    }\r\n    else {\r\n        _Input_onKeyDown.call(this, event);\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/rmmz/Input.ts?");

/***/ }),

/***/ "./ts/rmmz/PluginManager.ts":
/*!**********************************!*\
  !*** ./ts/rmmz/PluginManager.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst FlexWindowsManager_1 = __webpack_require__(/*! ts/core/FlexWindowsManager */ \"./ts/core/FlexWindowsManager.ts\");\r\n/** 外部から拡張するために Manager を公開する */\r\nPluginManager.flexWindowsManager = function () {\r\n    return FlexWindowsManager_1.FlexWindowsManager.instance;\r\n};\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/rmmz/PluginManager.ts?");

/***/ }),

/***/ "./ts/rmmz/SceneManager.ts":
/*!*********************************!*\
  !*** ./ts/rmmz/SceneManager.ts ***!
  \*********************************/
/***/ (() => {

eval("\r\nconst _SceneManager_onSceneCreate = SceneManager.onSceneCreate;\r\nSceneManager.onSceneCreate = function () {\r\n    _SceneManager_onSceneCreate.call(this);\r\n    // RMMZ の Window 構築は Scene の create() で行われる。\r\n    // その内容を UIElement に反映するため、確実に構築が終わったタイミングをフックする。\r\n    if (this._scene && this._scene._flexUIScene) {\r\n        this._scene._flexUIScene.onSceneCreate();\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/rmmz/SceneManager.ts?");

/***/ }),

/***/ "./ts/rmmz/Scene_Base.ts":
/*!*******************************!*\
  !*** ./ts/rmmz/Scene_Base.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst AnimationManager_1 = __webpack_require__(/*! ts/animation/AnimationManager */ \"./ts/animation/AnimationManager.ts\");\r\nconst FlexWindowsManager_1 = __webpack_require__(/*! ts/core/FlexWindowsManager */ \"./ts/core/FlexWindowsManager.ts\");\r\n// Scene_Title.initialize() 時点では Graphics.boxWidth が 0 なので、create で構築してみる。\r\nconst _Scene_Base_create = Scene_Base.prototype.create;\r\nScene_Base.prototype.create = function () {\r\n    _Scene_Base_create.call(this);\r\n    const manager = FlexWindowsManager_1.FlexWindowsManager.instance;\r\n    if (manager) {\r\n        manager.reloadSceneDesignIfNeeded(this);\r\n    }\r\n};\r\nconst _Scene_Base_addWindow = Scene_Base.prototype.addWindow;\r\nScene_Base.prototype.addWindow = function (window) {\r\n    _Scene_Base_addWindow.call(this, window);\r\n    // if (this._flexUIScene) {\r\n    //     this._flexUIScene.attachRmmzWindowIfNeeded(window);\r\n    // }\r\n};\r\nconst _Scene_Base_update = Scene_Base.prototype.update;\r\nScene_Base.prototype.update = function () {\r\n    _Scene_Base_update.call(this);\r\n    const manager = FlexWindowsManager_1.FlexWindowsManager.instance;\r\n    if (manager) {\r\n        manager.reloadSceneDesignIfNeeded(this);\r\n    }\r\n    if (this._flexUIScene) {\r\n        this._flexUIScene.context.update(Graphics.boxWidth, Graphics.boxHeight);\r\n    }\r\n    AnimationManager_1.VAnimation.update();\r\n};\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/rmmz/Scene_Base.ts?");

/***/ }),

/***/ "./ts/rmmz/Scene_Boot.ts":
/*!*******************************!*\
  !*** ./ts/rmmz/Scene_Boot.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst FlexWindowsManager_1 = __webpack_require__(/*! ts/core/FlexWindowsManager */ \"./ts/core/FlexWindowsManager.ts\");\r\nconst _Scene_Boot_create = Scene_Boot.prototype.create;\r\nScene_Boot.prototype.create = function () {\r\n    _Scene_Boot_create.call(this);\r\n    FlexWindowsManager_1.FlexWindowsManager.instance = new FlexWindowsManager_1.FlexWindowsManager();\r\n    FlexWindowsManager_1.FlexWindowsManager.instance.initialize();\r\n};\r\nconst _Scene_Boot_isReady = Scene_Boot.prototype.isReady;\r\nScene_Boot.prototype.isReady = function () {\r\n    if (!FlexWindowsManager_1.FlexWindowsManager.instance.isReady) {\r\n        return false;\r\n    }\r\n    return _Scene_Boot_isReady.call(this);\r\n};\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/rmmz/Scene_Boot.ts?");

/***/ }),

/***/ "./ts/rmmz/Window_Base.ts":
/*!********************************!*\
  !*** ./ts/rmmz/Window_Base.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst FlexWindowsManager_1 = __webpack_require__(/*! ts/core/FlexWindowsManager */ \"./ts/core/FlexWindowsManager.ts\");\r\nconst _Window_Base_initialize = Window_Base.prototype.initialize;\r\nWindow_Base.prototype.initialize = function (rect) {\r\n    // 本来であれば LogicalChild に追加した後の Layout で位置が決定されるのが自然だが、\r\n    // Rect は先にオーバーライドしておかないと、初期レイアウトが上手く動かない。\r\n    let actualRect = rect;\r\n    //const manager = FlexWindowsManager.instance;\r\n    const currentScene = SceneManager._scene;\r\n    const uiScene = currentScene._flexUIScene;\r\n    if (uiScene) {\r\n        const initialRect = uiScene.getRmmzWindowInitialRect(this.constructor.name);\r\n        if (initialRect) {\r\n            actualRect = new Rectangle(initialRect.x, initialRect.y, initialRect.width, initialRect.height);\r\n        }\r\n    }\r\n    _Window_Base_initialize.call(this, actualRect);\r\n    // 未初期化のプロパティにアクセスしないように、 Attach は Base.initialize() の後に行う必要がある。\r\n    if (uiScene) {\r\n        uiScene.attachRmmzWindowIfNeeded(this);\r\n    }\r\n};\r\nconst _Window_Base_createContents = Window_Base.prototype.createContents;\r\nWindow_Base.prototype.createContents = function () {\r\n    _Window_Base_createContents.call(this);\r\n    const width = this.contentsWidth();\r\n    const height = this.contentsHeight();\r\n    this._flexInfoContents = new Bitmap(width, height);\r\n    this._flexInfoSprite = new Sprite(this._flexInfoContents);\r\n    this._clientArea.addChild(this._flexInfoSprite);\r\n    this._flexInfoSprite.visible = false;\r\n    this._flexInfoSprite.x = 0;\r\n    this._flexInfoSprite.y = 0;\r\n    this._flexInfoContents.fillRect(0, 0, width, this.lineHeight(), \"rgba(0, 0, 0, 0.75)\");\r\n    this._flexInfoContents.drawText(this.constructor.name, 0, 0, width, this.lineHeight(), \"left\");\r\n};\r\nconst _Window_Base_destroyContents = Window_Base.prototype.destroyContents;\r\nWindow_Base.prototype.destroyContents = function () {\r\n    _Window_Base_destroyContents.call(this);\r\n    if (this._flexInfoSprite) {\r\n        this._clientArea.removeChild(this._flexInfoSprite);\r\n        this._flexInfoSprite = undefined;\r\n    }\r\n    if (this._flexInfoContents) {\r\n        this._flexInfoContents.destroy();\r\n        this._flexInfoContents = undefined;\r\n    }\r\n};\r\nconst _Window_Base_update = Window_Base.prototype.update;\r\nWindow_Base.prototype.update = function () {\r\n    _Window_Base_update.call(this);\r\n    if (this._flexInfoSprite) {\r\n        this._flexInfoSprite.visible = FlexWindowsManager_1.FlexWindowsManager.instance.displayWindowInfo;\r\n    }\r\n    // if (this._flexUILayoutContext) {\r\n    //     this._flexUILayoutContext.update();\r\n    // }\r\n};\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/rmmz/Window_Base.ts?");

/***/ }),

/***/ "./ts/rmmz/Window_Command.ts":
/*!***********************************!*\
  !*** ./ts/rmmz/Window_Command.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst _Window_Command_refresh = Window_Command.prototype.refresh;\r\nWindow_Command.prototype.refresh = function () {\r\n    this.clearCommandList();\r\n    this.makeCommandList();\r\n    Window_Selectable.prototype.refresh.call(this);\r\n};\r\nconst _Window_Selectable_drawAllItems = Window_Selectable.prototype.drawAllItems;\r\nWindow_Selectable.prototype.drawAllItems = function () {\r\n    _Window_Selectable_drawAllItems.call(this);\r\n    //this._contentsSprite.visible = false;\r\n    //this._contentsBackSprite.visible = false;\r\n};\r\n// const _Window_Command_itemWidth = Window_Command.prototype.itemWidth;\r\n// Window_Selectable.prototype.itemWidth = function() {\r\n//     return 50;\r\n//     return _Window_Command_itemWidth.call(this);\r\n// }\r\n// const _Window_Selectable_itemHeight = Window_Selectable.prototype.itemHeight;\r\n// Window_Selectable.prototype.itemHeight = function() {\r\n//     return 50;\r\n//     return _Window_Selectable_itemHeight.call(this);\r\n// };\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/rmmz/Window_Command.ts?");

/***/ }),

/***/ "./ts/ui/UIContainer.ts":
/*!******************************!*\
  !*** ./ts/ui/UIContainer.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.VUIContainer = void 0;\r\nconst UIElement_1 = __webpack_require__(/*! ./UIElement */ \"./ts/ui/UIElement.ts\");\r\nclass VUIContainer extends UIElement_1.VUIElement {\r\n    constructor(design) {\r\n        super(design);\r\n        this._contentChildren = [];\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        this._contentChildren.forEach((child) => child.dispose());\r\n        this._contentChildren = [];\r\n    }\r\n    addLogicalChild(element) {\r\n        element.itemIndex = this._contentChildren.length;\r\n        this._contentChildren.push(element);\r\n        element._parent = this;\r\n        this.addVisualChild(element);\r\n        return element;\r\n    }\r\n    contentChildren() {\r\n        return this._contentChildren;\r\n    }\r\n    findLogicalChildByClass(className) {\r\n        const result1 = super.findLogicalChildByClass(className);\r\n        if (result1) {\r\n            return result1;\r\n        }\r\n        for (const child of this._contentChildren) {\r\n            const result = child.findLogicalChildByClass(className);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    measureOverride(context, constraint) {\r\n        for (const child of this._contentChildren) {\r\n            child.measure(context, constraint);\r\n        }\r\n        return this.measureBasicBorderBoxSize();\r\n    }\r\n    arrangeOverride(context, borderBoxSize) {\r\n        const contentBox = { x: 0, y: 0, width: borderBoxSize.width, height: borderBoxSize.height };\r\n        for (const child of this._contentChildren) {\r\n            child.arrange(context, contentBox);\r\n        }\r\n        return super.arrangeOverride(context, contentBox);\r\n    }\r\n}\r\nexports.VUIContainer = VUIContainer;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/UIContainer.ts?");

/***/ }),

/***/ "./ts/ui/UIContext.ts":
/*!****************************!*\
  !*** ./ts/ui/UIContext.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIContext = exports.UISpiteLayer = void 0;\r\nconst Common_1 = __webpack_require__(/*! ts/core/Common */ \"./ts/core/Common.ts\");\r\nconst DStyle_1 = __webpack_require__(/*! ts/design/DStyle */ \"./ts/design/DStyle.ts\");\r\nconst UIElement_1 = __webpack_require__(/*! ./UIElement */ \"./ts/ui/UIElement.ts\");\r\nvar UISpiteLayer;\r\n(function (UISpiteLayer) {\r\n    UISpiteLayer[UISpiteLayer[\"Background\"] = 0] = \"Background\";\r\n    UISpiteLayer[UISpiteLayer[\"Foreground\"] = 1] = \"Foreground\";\r\n    UISpiteLayer[UISpiteLayer[\"Overlay\"] = 2] = \"Overlay\";\r\n})(UISpiteLayer = exports.UISpiteLayer || (exports.UISpiteLayer = {}));\r\nclass UIContext {\r\n    //private _refreshRequestedVisualContents: VUIElement[];\r\n    constructor(owner) {\r\n        this._layoutInitialing = false;\r\n        this._owner = owner;\r\n        //this._root = new UISelectableLayout();  // TODO;\r\n        this._firstUpdate = true;\r\n        //this._refreshRequestedVisualContents = [];\r\n    }\r\n    get layoutInitialing() {\r\n        return this._layoutInitialing;\r\n    }\r\n    get owner() {\r\n        return this._owner;\r\n    }\r\n    get currentWindow() {\r\n        (0, Common_1.assert)(this._window);\r\n        return this._window;\r\n    }\r\n    // public get rmmzSpriteOffset(): Window_Base | undefined {\r\n    // }\r\n    // public get currentContainer(): PIXI.Container {\r\n    //     if (this._window) {\r\n    //         return this._window;\r\n    //     }\r\n    //     return this._owner.owner;\r\n    // }\r\n    // public requestRefreshVisualContent(element: VUIElement): void {\r\n    //     if (!this._refreshRequestedVisualContents.find(x => x == element)) {\r\n    //         this._refreshRequestedVisualContents.push(element);\r\n    //     }\r\n    // }\r\n    addSprite(foreground, background) {\r\n        if (this._window) {\r\n            // _container に追加しないと、openness のエフェクトが効かない。\r\n            if (background)\r\n                this._window._container.addChildAt(background, 0);\r\n            if (foreground)\r\n                this._window._container.addChild(foreground);\r\n        }\r\n        else {\r\n            if (background)\r\n                this._owner.owner.addChildAt(background, 0);\r\n            if (foreground)\r\n                this._owner.owner.addChild(foreground);\r\n        }\r\n    }\r\n    addSprite2(layer, sprite) {\r\n        // TODO: layer\r\n        if (this._window) {\r\n            this._window._container.addChild(sprite);\r\n        }\r\n        else {\r\n            this._owner.owner.addChild(sprite);\r\n        }\r\n    }\r\n    getRectInCurrentContaier(actualRect) {\r\n        return actualRect; // TODO:\r\n    }\r\n    changeWindow(window) {\r\n        const old = this._window;\r\n        this._window = window;\r\n        return old;\r\n    }\r\n    update(width, height) {\r\n        if (this._firstUpdate) {\r\n            //FlexWindowsManager.instance.applyDesign(this._window);\r\n            this._firstUpdate = false;\r\n        }\r\n        if (this._owner.isInvalidate(UIElement_1.UIInvalidateFlags.Style)) {\r\n            this._owner._updateStyleHierarchical(this);\r\n        }\r\n        if (this._owner.isInvalidate(UIElement_1.UIInvalidateFlags.Layout)) {\r\n            this.layout(width, height);\r\n        }\r\n        // if (this._owner.isInvalidate(UIInvalidateFlags.VisualContent)) {\r\n        //     this.draw();\r\n        // }\r\n        if (this._owner.isInvalidate(UIElement_1.UIInvalidateFlags.ChildVisualContent)) {\r\n            this._owner.updateVisualContentsHierarchical(this);\r\n        }\r\n        // if (this._refreshRequestedVisualContents.length > 0) {\r\n        //     for (const element of this._refreshRequestedVisualContents) {\r\n        //         element.updateVisualContents(this);\r\n        //     }\r\n        //     this._refreshRequestedVisualContents = [];\r\n        // }\r\n    }\r\n    /** Windows の初期 Rect を確定するための layout. */\r\n    layoutInitial(width, height) {\r\n        (0, Common_1.assert)(this._owner);\r\n        this._layoutInitialing = true;\r\n        // コンストラクタで Default または Opening のスタイルが設定されているため、ここではスタイルを更新しない。\r\n        this._owner.measure(this, { width: width, height: height });\r\n        this._owner.arrange(this, { x: 0, y: 0, width: width, height: height });\r\n        this._layoutInitialing = false;\r\n    }\r\n    layout(width, height) {\r\n        (0, Common_1.assert)(this._owner);\r\n        console.log(\"========== layout begin ==========\", width, height, this);\r\n        this._owner.measure(this, {\r\n            width: width,\r\n            height: height\r\n        });\r\n        this._owner.arrange(this, {\r\n            x: 0, y: 0,\r\n            width: width,\r\n            height: height\r\n        });\r\n        this._owner.updateCombinedVisualRectHierarchical(this, { x: 0, y: 0, width: width, height: height });\r\n        //this._owner.updateRmmzRect();\r\n        this._owner.unsetInvalidate(UIElement_1.UIInvalidateFlags.Layout);\r\n    }\r\n    evaluateStyleValueAsString(element, value) {\r\n        if (value instanceof DStyle_1.DStyleScriptValue) {\r\n            const scene = this._owner;\r\n            const window = this._window;\r\n            const self = element;\r\n            value = eval(value.script);\r\n        }\r\n        if (value === undefined)\r\n            return \"\";\r\n        if (typeof value === \"string\")\r\n            return value;\r\n        if (typeof value === \"number\")\r\n            return value.toString();\r\n        if (typeof value === \"boolean\")\r\n            return value.toString();\r\n        return \"\";\r\n    }\r\n    testLayoutEnabled(element) {\r\n        return true;\r\n    }\r\n    draw() {\r\n        if (this._owner) {\r\n            this._owner.draw(this);\r\n            //this._owner.updateRmmzRect();\r\n            this._owner.unsetInvalidate(UIElement_1.UIInvalidateFlags.VisualContent);\r\n        }\r\n    }\r\n}\r\nexports.UIContext = UIContext;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/UIContext.ts?");

/***/ }),

/***/ "./ts/ui/UIElement.ts":
/*!****************************!*\
  !*** ./ts/ui/UIElement.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.VUIElement = exports.UIActualStyle = exports.UIElementFlags = exports.UIInvalidateFlags = exports.UIBoxSizing = exports.UIVisualStates = void 0;\r\nconst AnimationManager_1 = __webpack_require__(/*! ts/animation/AnimationManager */ \"./ts/animation/AnimationManager.ts\");\r\nconst Easing_1 = __webpack_require__(/*! ts/animation/Easing */ \"./ts/animation/Easing.ts\");\r\nconst Common_1 = __webpack_require__(/*! ts/core/Common */ \"./ts/core/Common.ts\");\r\nconst DElement_1 = __webpack_require__(/*! ts/design/DElement */ \"./ts/design/DElement.ts\");\r\nconst UIContext_1 = __webpack_require__(/*! ./UIContext */ \"./ts/ui/UIContext.ts\");\r\nconst UIStyle_1 = __webpack_require__(/*! ./UIStyle */ \"./ts/ui/UIStyle.ts\");\r\nconst UILayoutHelper_1 = __webpack_require__(/*! ./utils/UILayoutHelper */ \"./ts/ui/utils/UILayoutHelper.ts\");\r\nvar UIVisualStates;\r\n(function (UIVisualStates) {\r\n    UIVisualStates[\"Default\"] = \"Default\";\r\n    UIVisualStates[\"Opning\"] = \"Opening\";\r\n    UIVisualStates[\"Hover\"] = \"Hover\";\r\n    UIVisualStates[\"Pressed\"] = \"Pressed\";\r\n    UIVisualStates[\"Disabled\"] = \"Disabled\";\r\n})(UIVisualStates = exports.UIVisualStates || (exports.UIVisualStates = {}));\r\nvar UIBoxSizing;\r\n(function (UIBoxSizing) {\r\n    UIBoxSizing[\"ContentBox\"] = \"content-box\";\r\n    UIBoxSizing[\"BorderBox\"] = \"border-box\";\r\n})(UIBoxSizing = exports.UIBoxSizing || (exports.UIBoxSizing = {}));\r\nvar UIInvalidateFlags;\r\n(function (UIInvalidateFlags) {\r\n    UIInvalidateFlags[UIInvalidateFlags[\"None\"] = 0] = \"None\";\r\n    UIInvalidateFlags[UIInvalidateFlags[\"Style\"] = 2] = \"Style\";\r\n    UIInvalidateFlags[UIInvalidateFlags[\"Layout\"] = 4] = \"Layout\";\r\n    UIInvalidateFlags[UIInvalidateFlags[\"VisualContent\"] = 8] = \"VisualContent\";\r\n    // 以下内部用\r\n    // いずれかの子・孫要素が VisualContent を要求している。this は VisualContent を持っていないこともある。\r\n    UIInvalidateFlags[UIInvalidateFlags[\"ChildVisualContent\"] = 16] = \"ChildVisualContent\";\r\n    UIInvalidateFlags[UIInvalidateFlags[\"Opening\"] = 16] = \"Opening\";\r\n    UIInvalidateFlags[UIInvalidateFlags[\"All\"] = 65535] = \"All\";\r\n    UIInvalidateFlags[UIInvalidateFlags[\"Routing\"] = 22] = \"Routing\";\r\n    UIInvalidateFlags[UIInvalidateFlags[\"NoRouting\"] = 8] = \"NoRouting\";\r\n})(UIInvalidateFlags = exports.UIInvalidateFlags || (exports.UIInvalidateFlags = {}));\r\nvar UIElementFlags;\r\n(function (UIElementFlags) {\r\n    UIElementFlags[UIElementFlags[\"None\"] = 0] = \"None\";\r\n    UIElementFlags[UIElementFlags[\"RequireForegroundSprite\"] = 2] = \"RequireForegroundSprite\";\r\n    UIElementFlags[UIElementFlags[\"RequireBackgroundSprite\"] = 4] = \"RequireBackgroundSprite\";\r\n    UIElementFlags[UIElementFlags[\"ReadySprites\"] = 8] = \"ReadySprites\";\r\n    UIElementFlags[UIElementFlags[\"IsScene\"] = 16] = \"IsScene\";\r\n    UIElementFlags[UIElementFlags[\"All\"] = 65535] = \"All\";\r\n})(UIElementFlags = exports.UIElementFlags || (exports.UIElementFlags = {}));\r\nclass UIActualStyle {\r\n    constructor() {\r\n        this.defaultHorizontalAlignment = UILayoutHelper_1.UIHAlignment.Stretch;\r\n        this.defaultVerticalAlignment = UILayoutHelper_1.UIVAlignment.Stretch;\r\n        this.marginLeft = 0;\r\n        this.marginTop = 0;\r\n        this.marginRight = 0;\r\n        this.marginBottom = 0;\r\n        this.borderLeft = 0;\r\n        this.borderTop = 0;\r\n        this.borderRight = 0;\r\n        this.borderBottom = 0;\r\n        this.paddingLeft = 0;\r\n        this.paddingTop = 0;\r\n        this.paddingRight = 0;\r\n        this.paddingBottom = 0;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        // this.width = 0;\r\n        // this.height = 0;\r\n        this.colorTone = [0, 0, 0, 1];\r\n        this.opacity = 255; // 全体\r\n        this.backOpacity = 255;\r\n        this.contentsOpacity = 255;\r\n        this.originX = 0;\r\n        this.originY = 0;\r\n        this.frameVisible = true;\r\n    }\r\n    get marginWidth() { return this.marginLeft + this.marginRight; }\r\n    get marginHeight() { return this.marginTop + this.marginBottom; }\r\n    get borderWidth() { return this.borderLeft + this.borderRight; }\r\n    get borderHeight() { return this.borderTop + this.borderBottom; }\r\n    get paddingWidth() { return this.paddingLeft + this.paddingRight; }\r\n    get paddingHeight() { return this.paddingTop + this.paddingBottom; }\r\n    set padding(value) {\r\n        this.paddingLeft = value;\r\n        this.paddingTop = value;\r\n        this.paddingRight = value;\r\n        this.paddingBottom = value;\r\n    }\r\n    getHorizontalAlignment() { var _a; return (_a = this.horizontalAlignment) !== null && _a !== void 0 ? _a : this.defaultHorizontalAlignment; }\r\n    getVerticalAlignment() { var _a; return (_a = this.verticalAlignment) !== null && _a !== void 0 ? _a : this.defaultVerticalAlignment; }\r\n    getInvalidateFlags(propertyName) {\r\n        switch (propertyName) {\r\n            case \"x\":\r\n            case \"y\":\r\n            case \"width\":\r\n            case \"height\":\r\n                return UIInvalidateFlags.Layout | UIInvalidateFlags.VisualContent;\r\n            case \"background\":\r\n            case \"foreground\":\r\n                return UIInvalidateFlags.VisualContent;\r\n        }\r\n        return UIInvalidateFlags.None;\r\n    }\r\n}\r\nexports.UIActualStyle = UIActualStyle;\r\n/**\r\n *\r\n * Box Model\r\n * ----------\r\n * UIElement の Box-Model は、 CSS の border-box 相当です。\r\n * つまり次のようになります。\r\n * - width、height プロパティで指定できる領域に padding + border 領域を含める。\r\n * - width、height プロパティで指定できる領域には、margin 領域は含めない。\r\n * これは、本プラグインの重要なコンセプトのひとつの「コンテンツ領域外のウィンドウの装飾が簡単にできること」を実現するためです。\r\n * すなわち、何らかの描画が行われる領域の左上が、コンテンツ(子要素)の原点となります。\r\n *\r\n * desiredSize\r\n * ----------\r\n * desiredSize は、子要素のサイズを考慮した、この要素の理想的なレイアウトサイズです。\r\n * 設定に関わらず、常に MerginBox と等しくなります。\r\n */\r\nclass VUIElement {\r\n    // x: number;\r\n    // y: number;\r\n    // opacity: number;    // 0~1.0\r\n    constructor(design) {\r\n        var _a;\r\n        this.design = design;\r\n        this._margin = {\r\n            top: 0,\r\n            right: 0,\r\n            bottom: 0,\r\n            left: 0,\r\n        };\r\n        this._padding = {\r\n            top: 0,\r\n            right: 0,\r\n            bottom: 0,\r\n            left: 0,\r\n        };\r\n        this._desiredWidth = 0;\r\n        this._desiredHeight = 0;\r\n        this._actualMarginBoxRect = { x: 0, y: 0, width: 0, height: 0 };\r\n        this._combinedVisualRect = { x: 0, y: 0, width: 0, height: 0 };\r\n        // this._actualWidth = 0;\r\n        // this._actualHeight = 0;t\r\n        this.itemIndex = 0;\r\n        this.row = 0;\r\n        this.col = 0;\r\n        this.rowSpan = 1;\r\n        this.colSpan = 1;\r\n        // this.x = 0;\r\n        // this.y = 0;\r\n        // this.opacity = 1.0;\r\n        this._styles = [new UIStyle_1.UIStyle(design.defaultStyle)];\r\n        for (const style of (_a = design.props.styles) !== null && _a !== void 0 ? _a : []) {\r\n            this._styles.push(new UIStyle_1.UIStyle(style));\r\n        }\r\n        this.actualStyle = new UIActualStyle();\r\n        this._boxSizing = UIBoxSizing.BorderBox;\r\n        this._invalidateFlags = UIInvalidateFlags.All;\r\n        this._flags = UIElementFlags.None;\r\n        this._visualChildren = [];\r\n        this._visualState = UIVisualStates.Default;\r\n        // 最初は opening で設定し、次の update 時に default が適用されるようにする\r\n        // if (this.applyStyleByName(\"Opening\", true)) {\r\n        //     this.setInvalidate(UIInvalidateFlags.Style);\r\n        // }\r\n        // else {\r\n        //     this.unsetInvalidate(UIInvalidateFlags.Style);\r\n        // }\r\n        var min = 1;\r\n        var max = 1000000000;\r\n        this.id = Math.floor(Math.random() * (max + 1 - min)) + min;\r\n        {\r\n            switch (this.design.props.alignment) {\r\n                case undefined:\r\n                    break;\r\n                case DElement_1.DAlignment.Center:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Center;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Center;\r\n                    break;\r\n                case DElement_1.DAlignment.Left:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Left;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Center;\r\n                    break;\r\n                case DElement_1.DAlignment.Right:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Right;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Center;\r\n                    break;\r\n                case DElement_1.DAlignment.Top:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Center;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Top;\r\n                    break;\r\n                case DElement_1.DAlignment.Bottom:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Center;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Bottom;\r\n                    break;\r\n                case DElement_1.DAlignment.TopLeft:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Left;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Top;\r\n                    break;\r\n                case DElement_1.DAlignment.TopRight:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Right;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Top;\r\n                    break;\r\n                case DElement_1.DAlignment.BottomLeft:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Left;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Bottom;\r\n                    break;\r\n                case DElement_1.DAlignment.BottomRight:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Right;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Bottom;\r\n                    break;\r\n                case DElement_1.DAlignment.LeftStretch:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Left;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Stretch;\r\n                    break;\r\n                case DElement_1.DAlignment.TopStretch:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Stretch;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Top;\r\n                    break;\r\n                case DElement_1.DAlignment.RightStretch:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Right;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Stretch;\r\n                    break;\r\n                case DElement_1.DAlignment.BottomStretch:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Stretch;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Bottom;\r\n                    break;\r\n                case DElement_1.DAlignment.HorizontalStretch:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Stretch;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Center;\r\n                    break;\r\n                case DElement_1.DAlignment.VerticalStretch:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Center;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Stretch;\r\n                    break;\r\n                case DElement_1.DAlignment.Stretch:\r\n                    this.actualStyle.horizontalAlignment = UILayoutHelper_1.UIHAlignment.Stretch;\r\n                    this.actualStyle.verticalAlignment = UILayoutHelper_1.UIVAlignment.Stretch;\r\n                    break;\r\n                default:\r\n                    throw new Error(\"unknown alignment: \" + this.design.props.alignment);\r\n            }\r\n        }\r\n    }\r\n    dispose() {\r\n        if (this._foregroundSprite) {\r\n            this._foregroundSprite.destroy();\r\n            this._foregroundSprite = undefined;\r\n        }\r\n        if (this._foregroundBitmap) {\r\n            this._foregroundBitmap.destroy();\r\n            this._foregroundBitmap = undefined;\r\n        }\r\n        if (this._backgroundSprite) {\r\n            this._backgroundSprite.destroy();\r\n            this._backgroundSprite = undefined;\r\n        }\r\n        if (this._backgroundBitmap) {\r\n            this._backgroundBitmap.destroy();\r\n            this._backgroundBitmap = undefined;\r\n        }\r\n    }\r\n    // private onApplyDesign(): void {\r\n    // }\r\n    setInvalidate(flags) {\r\n        // VisualContent の変更は ChildVisualContent を伴う\r\n        if ((flags & UIInvalidateFlags.VisualContent) !== 0) {\r\n            flags |= UIInvalidateFlags.ChildVisualContent;\r\n        }\r\n        const oldRoutingFlags = this._invalidateFlags & UIInvalidateFlags.Routing;\r\n        if (this._invalidateFlags != flags) {\r\n            this._invalidateFlags |= flags;\r\n            const newRoutingFlags = this._invalidateFlags & UIInvalidateFlags.Routing;\r\n            if (oldRoutingFlags != newRoutingFlags) {\r\n                if (this._parent) {\r\n                    this._parent.setInvalidate(newRoutingFlags);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    unsetInvalidate(flags) {\r\n        this._invalidateFlags &= ~flags;\r\n    }\r\n    isInvalidate(flags) {\r\n        return (this._invalidateFlags & flags) !== 0;\r\n    }\r\n    setFlags(flags) {\r\n        this._flags |= flags;\r\n    }\r\n    unsetFlags(flags) {\r\n        this._flags &= ~flags;\r\n    }\r\n    hasFlags(flags) {\r\n        return (this._flags & flags) !== 0;\r\n    }\r\n    findPIXIContainer() {\r\n        if (this._parent) {\r\n            return this._parent.findPIXIContainer();\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    addLogicalChild(element) {\r\n        throw new Error(\"Unreachable.\");\r\n        return element;\r\n    }\r\n    setParent(parent) {\r\n        (0, Common_1.assert)(!this._parent);\r\n        this._parent = parent;\r\n        // if (this._parent) {\r\n        //     this.setInvalidate(UIInvalidateFlags.All);\r\n        // }\r\n    }\r\n    findLogicalChildByClass(className) {\r\n        if (this.design.props.class === className) {\r\n            return this;\r\n        }\r\n        return undefined;\r\n    }\r\n    calcContentOuter() {\r\n        return {\r\n            top: this._margin.top + this._padding.top,\r\n            right: this._margin.right + this._padding.right,\r\n            bottom: this._margin.bottom + this._padding.bottom,\r\n            left: this._margin.left + this._padding.left,\r\n        };\r\n    }\r\n    margin(top, right, bottom, left) {\r\n        if (right !== undefined && bottom !== undefined && left !== undefined) {\r\n            this._margin.top = top;\r\n            this._margin.right = right;\r\n            this._margin.bottom = bottom;\r\n            this._margin.left = left;\r\n        }\r\n        else if (right !== undefined) {\r\n            this._margin.top = this._margin.bottom = top;\r\n            this._margin.right = this._margin.left = right;\r\n        }\r\n        else {\r\n            this._margin.top = this._margin.bottom = this._margin.right = this._margin.left = top;\r\n        }\r\n        return this;\r\n    }\r\n    getMargin() {\r\n        return this._margin;\r\n    }\r\n    padding() {\r\n        return this._padding;\r\n    }\r\n    setGrid(col, row, colSpan = 1, rowSpan = 1) {\r\n        this.row = row;\r\n        this.col = col;\r\n        this.rowSpan = rowSpan;\r\n        this.colSpan = colSpan;\r\n        return this;\r\n    }\r\n    // public setOpacity(value: number): this {\r\n    //     this.opacity = value;\r\n    //     return this;\r\n    // }\r\n    // public addTo(container: VUIContainer): this {\r\n    //     container.addChild(this);\r\n    //     return this;\r\n    // }\r\n    //--------------------------------------------------------------------------\r\n    // Visual tree\r\n    addVisualChild(element) {\r\n        (0, Common_1.assert)(!element._visualParent);\r\n        this._visualChildren.push(element);\r\n        element._visualParent = this;\r\n    }\r\n    get visualChildren() {\r\n        return this._visualChildren;\r\n    }\r\n    get visualParent() {\r\n        return this._visualParent;\r\n    }\r\n    traverseVisualChildren(callback) {\r\n        for (const child of this._visualChildren) {\r\n            callback(child);\r\n            child.traverseVisualChildren(callback);\r\n        }\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // Style\r\n    setValue(context, propertyName, value, reset) {\r\n        const obj = this.actualStyle;\r\n        if (reset) {\r\n            this.setActualStyleValueInternal(propertyName, value);\r\n            return;\r\n        }\r\n        if (obj[propertyName] === value) {\r\n            return;\r\n        }\r\n        const container = this.findPIXIContainer();\r\n        const transition = this.design.transitions.find(x => x.property === propertyName);\r\n        if (container && transition) {\r\n            const start = obj[propertyName];\r\n            AnimationManager_1.VAnimation.startAt(container, `${this.id}.${propertyName}`, start, value, transition.duration, Easing_1.easing.linear, v => {\r\n                this.setActualStyleValueInternal(propertyName, v);\r\n            }, transition.delay);\r\n        }\r\n        else {\r\n            this.setActualStyleValueInternal(propertyName, value);\r\n        }\r\n    }\r\n    setActualStyleValueInternal(propertyName, value) {\r\n        const obj = this.actualStyle;\r\n        obj[propertyName] = value;\r\n        this.setInvalidate(this.actualStyle.getInvalidateFlags(propertyName));\r\n    }\r\n    applyStyle(context, style, reset) {\r\n        console.log(\"applyStyle\", this, style);\r\n        style.evaluate(context, this);\r\n        const props = style;\r\n        if (props.marginLeft)\r\n            this.setValue(context, \"marginLeft\", props.marginLeft, reset);\r\n        if (props.marginTop)\r\n            this.setValue(context, \"marginTop\", props.marginTop, reset);\r\n        if (props.marginRight)\r\n            this.setValue(context, \"marginRight\", props.marginRight, reset);\r\n        if (props.marginBottom)\r\n            this.setValue(context, \"marginBottom\", props.marginBottom, reset);\r\n        if (props.paddingLeft)\r\n            this.setValue(context, \"paddingLeft\", props.paddingLeft, reset);\r\n        if (props.paddingTop)\r\n            this.setValue(context, \"paddingTop\", props.paddingTop, reset);\r\n        if (props.paddingRight)\r\n            this.setValue(context, \"paddingRight\", props.paddingRight, reset);\r\n        if (props.paddingBottom)\r\n            this.setValue(context, \"paddingBottom\", props.paddingBottom, reset);\r\n        if (props.x)\r\n            this.setValue(context, \"x\", props.x, reset);\r\n        if (props.y)\r\n            this.setValue(context, \"y\", props.y, reset);\r\n        if (props.width)\r\n            this.setValue(context, \"width\", props.width, reset);\r\n        if (props.height)\r\n            this.setValue(context, \"height\", props.height, reset);\r\n        // this.setValue(\"x\", props.x ?? defaultRect.x, reset);\r\n        // this.setValue(\"y\", props.y ?? defaultRect.y, reset);\r\n        // this.setValue(\"width\", props.width ?? defaultRect.width, reset);\r\n        // this.setValue(\"height\", props.height ?? defaultRect.height, reset);\r\n        //if (props.windowskin) this.setValue(\"windowskin\", props.windowskin);\r\n        //if (props.colorTone) this.setValue(\"colorTone\", props.colorTone);\r\n        if (props.opacity)\r\n            this.setValue(context, \"opacity\", props.opacity, reset);\r\n        if (props.backOpacity)\r\n            this.setValue(context, \"backOpacity\", props.backOpacity, reset);\r\n        if (props.contentsOpacity)\r\n            this.setValue(context, \"contentsOpacity\", props.contentsOpacity, reset);\r\n        if (props.background)\r\n            this.setActualStyleValueInternal(\"background\", props.background);\r\n        if (props.originX)\r\n            this.setValue(context, \"originX\", props.originX, reset);\r\n        if (props.originY)\r\n            this.setValue(context, \"originY\", props.originY, reset);\r\n        //if (props.frameVisible) this.setValue(\"frameVisible\", props.frameVisible);\r\n        this.onStyleUpdated(context);\r\n    }\r\n    // public setVisualState(state: UIVisualStates): void {\r\n    //     if (this._visualState == state) {\r\n    //         this._visualState = state;\r\n    //         this.setInvalidate(UIInvalidateFlags.Style);\r\n    //     }\r\n    // }\r\n    _updateStyleHierarchical(context) {\r\n        this.updateStyle(context);\r\n        for (const child of this._visualChildren) {\r\n            child._updateStyleHierarchical(context);\r\n        }\r\n    }\r\n    updateStyle(context) {\r\n        if (this.isInvalidate(UIInvalidateFlags.Style)) {\r\n            this.unsetInvalidate(UIInvalidateFlags.Style);\r\n            this.applyStyleByName(context, this._visualState, false);\r\n        }\r\n    }\r\n    findStyle(stateName) {\r\n        for (const style of this._styles) {\r\n            if (style.stateName === stateName) {\r\n                return style;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    applyStyleByName(context, state, reset) {\r\n        const style = this.findStyle(state);\r\n        if (style) {\r\n            this.applyStyle(context, style, reset);\r\n            return true;\r\n        }\r\n        else {\r\n            this.applyStyle(context, this._styles[0], reset);\r\n            return false;\r\n        }\r\n    }\r\n    onStyleUpdated(context) {\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // Layout\r\n    /** 子要素は考慮せず、この UIElement のスタイルを元にした最小サイズ。 */\r\n    measureBasicBorderBoxSize() {\r\n        var _a, _b, _c, _d;\r\n        switch (this._boxSizing) {\r\n            case UIBoxSizing.ContentBox:\r\n                const width = ((_a = this.actualStyle.width) !== null && _a !== void 0 ? _a : 0) + (this.actualStyle.borderLeft + this.actualStyle.borderRight) + (this.actualStyle.paddingLeft + this.actualStyle.paddingRight);\r\n                const height = ((_b = this.actualStyle.height) !== null && _b !== void 0 ? _b : 0) + (this.actualStyle.borderTop + this.actualStyle.borderBottom) + (this.actualStyle.paddingTop + this.actualStyle.paddingBottom);\r\n                return { width, height };\r\n            case UIBoxSizing.BorderBox:\r\n                return { width: (_c = this.actualStyle.width) !== null && _c !== void 0 ? _c : 0, height: (_d = this.actualStyle.height) !== null && _d !== void 0 ? _d : 0 };\r\n            default:\r\n                throw new Error(\"Unknown box-sizing: \" + this._boxSizing);\r\n        }\r\n    }\r\n    setDesiredSize(width, height) {\r\n        this._desiredWidth = width;\r\n        this._desiredHeight = height;\r\n    }\r\n    get desiredSize() {\r\n        return { width: this._desiredWidth, height: this._desiredHeight };\r\n    }\r\n    desiredWidth() {\r\n        return this._desiredWidth;\r\n    }\r\n    desiredHeight() {\r\n        return this._desiredHeight;\r\n    }\r\n    /**\r\n     * この要素を表示するために必要なサイズを計測します。結果は desiredSize に格納されます。\r\n     *\r\n     * @param context\r\n     * @param availableSize 親要素が子要素を割り当てることができる使用可能な領域。\r\n     *                      通常、レイアウトスロットのサイズを指定します。\r\n     *\r\n     */\r\n    measure(context, availableSize) {\r\n        const marginWidth = this.actualStyle.marginWidth;\r\n        const marginHeight = this.actualStyle.marginHeight;\r\n        const borderWidth = this.actualStyle.borderWidth;\r\n        const borderHeight = this.actualStyle.borderHeight;\r\n        const paddingWidth = this.actualStyle.paddingWidth;\r\n        const paddingHeight = this.actualStyle.paddingHeight;\r\n        const width = Math.max(0.0, availableSize.width - marginWidth);\r\n        const height = Math.max(0.0, availableSize.height - marginHeight);\r\n        const contentSize = this.measureOverride(context, { width: width, height: height });\r\n        (0, Common_1.assert)(Number.isFinite(contentSize.width));\r\n        (0, Common_1.assert)(Number.isFinite(contentSize.height));\r\n        this.setDesiredSize(contentSize.width + marginWidth, // + borderWidth + paddingWidth,\r\n        contentSize.height + marginHeight); // + borderHeight + paddingHeight);\r\n    }\r\n    /**\r\n     * この要素を表示するために必要なサイズを計測します。\r\n     *\r\n     * @param context\r\n     * @param constraint 要素を配置できる領域の最大サイズ。通常は親要素のサイズが渡されます。\r\n     *                   スクロール領域の場合は Inf が渡されることがあるので注意してください。\r\n     * @returns BorderBox の希望サイズ。\r\n     */\r\n    measureOverride(context, constraint) {\r\n        return this.measureBasicBorderBoxSize();\r\n        // 基本は、親レイアウトスロット一杯に広がると考えてよい。\r\n        // スクロールエリアの場合はちゃんとオーバーライドして計算する必要があるが、\r\n        // base としては inf を返さないようにしておく。\r\n        // return {\r\n        //     width: ((Number.isFinite(constraint.width)) ? constraint.width : 0),\r\n        //     height: ((Number.isFinite(constraint.height)) ? constraint.height : 0),\r\n        // };\r\n    }\r\n    /**\r\n     *\r\n     * @param context\r\n     * @param finalArea 親要素のローカル座標において、 親要素がこの要素に対して割り当てた領域のサイズ（レイアウトスロットの Rect）\r\n     * @returns\r\n     */\r\n    arrange(context, finalArea) {\r\n        // https://developer.mozilla.org/ja/docs/Learn/CSS/Building_blocks/The_box_model#%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%81%AE%E6%A7%8B%E6%88%90\r\n        // const localMarginBox = {\r\n        //     x: finalArea.x + this.actualStyle.marginLeft,\r\n        //     y: finalArea.y + this.actualStyle.marginTop,\r\n        //     width: finalArea.width - this.actualStyle.marginLeft - this.actualStyle.marginRight,\r\n        //     height: finalArea.height - this.actualStyle.marginTop - this.actualStyle.marginBottom,\r\n        // };\r\n        console.log(\"arrange\", this, finalArea);\r\n        (0, Common_1.assert)(!Number.isNaN(this._desiredWidth));\r\n        (0, Common_1.assert)(!Number.isNaN(this._desiredHeight));\r\n        // width/height が直接指定されていれば、desiredSize は最低でもその分の大きさがなければならない。\r\n        if (this.actualStyle.width !== undefined) {\r\n            (0, Common_1.assert)(this._desiredWidth >= this.actualStyle.width);\r\n        }\r\n        if (this.actualStyle.height !== undefined) {\r\n            (0, Common_1.assert)(this._desiredHeight >= this.actualStyle.height);\r\n        }\r\n        const marginWidth = this.actualStyle.marginWidth;\r\n        const marginHeight = this.actualStyle.marginHeight;\r\n        // CSS の border-box 相当なので、一番外側 (margin-box) のサイズ計算はこんな感じ。\r\n        const marginBoxWidthOrUndefined = (this.actualStyle.width === undefined) ? undefined : this._desiredWidth + marginWidth;\r\n        const marginBoxHeightOrUndefined = (this.actualStyle.height === undefined) ? undefined : this._desiredHeight + marginHeight;\r\n        const marginBox = { x: 0, y: 0, width: 0, height: 0 };\r\n        UILayoutHelper_1.UILayoutHelper.adjustHorizontalAlignment(finalArea.width, this._desiredWidth, marginBoxWidthOrUndefined, this.actualStyle.getHorizontalAlignment(), marginBox);\r\n        UILayoutHelper_1.UILayoutHelper.adjustVerticalAlignment(finalArea.height, this._desiredHeight, marginBoxHeightOrUndefined, this.actualStyle.getVerticalAlignment(), marginBox);\r\n        const borderBoxSize = {\r\n            width: marginBox.width - marginWidth,\r\n            height: marginBox.height - marginHeight\r\n        };\r\n        const result = this.arrangeOverride(context, borderBoxSize);\r\n        this.setActualRect({ x: finalArea.x + marginBox.x, y: finalArea.y + marginBox.y, width: result.width, height: result.height });\r\n    }\r\n    /**\r\n     *\r\n     * @param context\r\n     * @param borderBoxSize\r\n     * @returns\r\n     *\r\n     * なぜ BorderBoxSize なのか？\r\n     * ----------\r\n     * Decoration をレイアウトできるようにするため。\r\n     * これは box-sizing に関わらず、何かしらの可視 Box と同じ範囲にレイアウトしたい。 （BorderBox の左上を (0, 0) にしたい）\r\n     * 論理的な子要素を配置するべき Box は、 getLocalClientBox() を使うこと。\r\n     */\r\n    arrangeOverride(context, borderBoxSize) {\r\n        //this.setActualRect({x: 0, y: 0, width: contentSize.width, height: contentSize.height});\r\n        return borderBoxSize;\r\n    }\r\n    makeBorderBoxSize(clientSize) {\r\n        // switch (this._boxSizing) {\r\n        //     case UIBoxSizing.BorderBox:\r\n        //         return clientSize;\r\n        //     case UIBoxSizing.ContentBox:\r\n        return {\r\n            width: clientSize.width + this.actualStyle.borderWidth + this.actualStyle.paddingWidth,\r\n            height: clientSize.height + this.actualStyle.borderHeight + this.actualStyle.paddingHeight,\r\n        };\r\n        //     default:\r\n        //         throw new Error(\"Unknown box-sizing\");\r\n        // }\r\n    }\r\n    /** arrangeOverride() の中で使う。BorderBox を基準とした ローカルの ContentBox を求める。 */\r\n    makeContentBoxSize(borderBoxSize) {\r\n        return {\r\n            x: this.actualStyle.paddingLeft,\r\n            y: this.actualStyle.paddingTop,\r\n            width: borderBoxSize.width - this.actualStyle.paddingWidth,\r\n            height: borderBoxSize.height - this.actualStyle.paddingHeight,\r\n        };\r\n    }\r\n    // protected getClientBoxSize(): VUISize {\r\n    //     switch (this._boxSizing) {\r\n    //         case UIBoxSizing.BorderBox:\r\n    //             return {\r\n    //                 width: this.actualStyle.width ?? 0,\r\n    //                 height: this.actualStyle.height ?? 0,\r\n    //             };\r\n    //         case UIBoxSizing.ContentBox:\r\n    //             return {\r\n    //                 width: this._actualBorderBoxRect.width - this.actualStyle.borderLeft - this.actualStyle.borderRight,\r\n    //                 height: this._actualBorderBoxRect.height - this.actualStyle.borderTop - this.actualStyle.borderBottom,\r\n    //             };\r\n    //         default:\r\n    //             throw new Error(\"Unknown box-sizing\");\r\n    //     }\r\n    // }\r\n    getLocalClientBox(borderBoxSize) {\r\n        // switch (this._boxSizing) {\r\n        //     case UIBoxSizing.ContentBox:\r\n        return {\r\n            x: this.actualStyle.borderLeft + this.actualStyle.paddingLeft,\r\n            y: this.actualStyle.borderTop + this.actualStyle.paddingTop,\r\n            width: borderBoxSize.width - (this.actualStyle.borderLeft + this.actualStyle.borderRight) - (this.actualStyle.paddingLeft + this.actualStyle.paddingRight),\r\n            height: borderBoxSize.height - (this.actualStyle.borderTop + this.actualStyle.borderBottom) - (this.actualStyle.paddingTop + this.actualStyle.paddingBottom)\r\n        };\r\n        //     case UIBoxSizing.BorderBox:\r\n        //         return {\r\n        //             x: 0,\r\n        //             y: 0,\r\n        //             width: borderBoxSize.width,\r\n        //             height: borderBoxSize.height };\r\n        //     default:\r\n        //         throw new Error(\"Unknown box-sizing\");\r\n        // }\r\n    }\r\n    setActualRect(rect) {\r\n        this._actualMarginBoxRect = Object.assign({}, rect);\r\n        this._actualMarginBoxRect.x += this.actualStyle.x;\r\n        this._actualMarginBoxRect.y += this.actualStyle.y;\r\n    }\r\n    actualRect() {\r\n        return this._actualMarginBoxRect;\r\n    }\r\n    /**\r\n     * updateCombinedVisualRect\r\n     *\r\n     * visualRect とは、この要素の描画領域を表す矩形。CSS の border-box 相当 では BorderBox.\r\n     * CombinedVisualRect は、実際に RMMZ の Window や Sprite に適用できる Rect.\r\n     * つまり、直近の親 PIXI.Container のローカル座標系内の Rect となる。\r\n     */\r\n    updateCombinedVisualRectHierarchical(context, parentCombinedVisualRect) {\r\n        //this._combinedVisualRect = this.updateCombinedVisualRectOverride(context, parentCombinedVisualRect);\r\n        this.updateCombinedVisualRect(context, parentCombinedVisualRect);\r\n        for (const child of this._visualChildren) {\r\n            child.updateCombinedVisualRectHierarchical(context, this._combinedVisualRect);\r\n        }\r\n    }\r\n    updateCombinedVisualRect(context, parentCombinedVisualRect) {\r\n        this._combinedVisualRect.x = parentCombinedVisualRect.x + this._actualMarginBoxRect.x;\r\n        this._combinedVisualRect.y = parentCombinedVisualRect.y + this._actualMarginBoxRect.y;\r\n        this._combinedVisualRect.width = this._actualMarginBoxRect.width;\r\n        this._combinedVisualRect.height = this._actualMarginBoxRect.height;\r\n        this.unsetInvalidate(UIInvalidateFlags.Layout);\r\n        this.onLayoutFixed(context, this._combinedVisualRect);\r\n    }\r\n    getCombinedVisualRect() {\r\n        return this._combinedVisualRect;\r\n    }\r\n    setCombinedVisualRect(rect) {\r\n        this._combinedVisualRect = rect;\r\n    }\r\n    // protected updateCombinedVisualRectOverride(context: UIContext, parentCombinedVisualRect: VUIRect): VUIRect {\r\n    //     return {\r\n    //         x: parentCombinedVisualRect.x + this._actualBorderBoxRect.x,\r\n    //         y: parentCombinedVisualRect.y + this._actualBorderBoxRect.y,\r\n    //         width: this._actualBorderBoxRect.width,\r\n    //         height: this._actualBorderBoxRect.height,\r\n    //     };\r\n    //     // this._combinedVisualRect.x = parentCombinedVisualRect.x + this._actualBorderBoxRect.x;\r\n    //     // this._combinedVisualRect.y = parentCombinedVisualRect.y + this._actualBorderBoxRect.y;\r\n    //     // this._combinedVisualRect.width = this._actualBorderBoxRect.width;\r\n    //     // this._combinedVisualRect.height = this._actualBorderBoxRect.height;\r\n    // }\r\n    // public updateRmmzRect(): void {\r\n    //     this.onSetRmmzRect(this._actualBorderBoxRect);\r\n    // }\r\n    // protected onSetRmmzRect(actualRect: VUIRect): void {\r\n    // }\r\n    onLayoutFixed(context, combinedVisualRect) {\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // Visual\r\n    prepareSprites(context) {\r\n        if (!this.hasFlags(UIElementFlags.ReadySprites)) {\r\n            this.setFlags(UIElementFlags.ReadySprites);\r\n            if (this.hasFlags(UIElementFlags.RequireForegroundSprite)) {\r\n                if (!this._foregroundBitmap) {\r\n                    this._foregroundBitmap = new Bitmap(this._combinedVisualRect.width, this._combinedVisualRect.height);\r\n                }\r\n                if (!this._foregroundSprite) {\r\n                    this._foregroundSprite = new Sprite(this._foregroundBitmap);\r\n                }\r\n            }\r\n            if (this.hasFlags(UIElementFlags.RequireBackgroundSprite)) {\r\n                if (!this._backgroundBitmap) {\r\n                    if (this.actualStyle.background) {\r\n                        this._backgroundBitmap = ImageManager.loadSystem(this.actualStyle.background);\r\n                    }\r\n                    else {\r\n                        this._backgroundBitmap = new Bitmap(this._combinedVisualRect.width, this._combinedVisualRect.height);\r\n                    }\r\n                }\r\n                if (!this._backgroundSprite) {\r\n                    this._backgroundSprite = new Sprite(this._backgroundBitmap);\r\n                }\r\n            }\r\n            context.addSprite(this._foregroundSprite, this._backgroundSprite);\r\n        }\r\n        if (this._foregroundSprite) {\r\n            this._foregroundSprite.x = this._combinedVisualRect.x;\r\n            this._foregroundSprite.y = this._combinedVisualRect.y;\r\n        }\r\n        if (this._backgroundSprite) {\r\n            this._backgroundSprite.x = this._combinedVisualRect.x;\r\n            this._backgroundSprite.y = this._combinedVisualRect.y;\r\n            this._backgroundSprite.opacity = this.actualStyle.opacity;\r\n        }\r\n        if (this._debugSprite) {\r\n            this._debugSprite.x = this._combinedVisualRect.x;\r\n            this._debugSprite.y = this._combinedVisualRect.y;\r\n        }\r\n    }\r\n    /** onRefreshVisual() で使える。 */\r\n    prepareForegroundSprite(context, bitmap) {\r\n        if (!this._foregroundSprite) {\r\n            this._foregroundSprite = new Sprite(undefined);\r\n            context.addSprite2(UIContext_1.UISpiteLayer.Foreground, this._foregroundSprite);\r\n        }\r\n        if (bitmap) {\r\n            this._foregroundSprite.bitmap = bitmap;\r\n        }\r\n        else {\r\n            if (!this._foregroundBitmap || (this._foregroundBitmap.width != this._combinedVisualRect.width || this._foregroundBitmap.height != this._combinedVisualRect.height)) {\r\n                if (this._foregroundBitmap) {\r\n                    this._foregroundBitmap.destroy();\r\n                }\r\n                this._foregroundBitmap = new Bitmap(this._combinedVisualRect.width, this._combinedVisualRect.height);\r\n                this._foregroundSprite.bitmap = this._foregroundBitmap;\r\n            }\r\n        }\r\n        this._foregroundSprite.x = this._combinedVisualRect.x;\r\n        this._foregroundSprite.y = this._combinedVisualRect.y;\r\n        this._foregroundSprite.opacity = this.actualStyle.opacity;\r\n        return this._foregroundSprite;\r\n    }\r\n    /** onRefreshVisual() で使える。 */\r\n    prepareBackgroundSprite(context) {\r\n        this.prepareSprites(context);\r\n        (0, Common_1.assert)(this._backgroundSprite);\r\n        return this._backgroundSprite;\r\n    }\r\n    prepareDebugSprite(context) {\r\n        // UIScene の場合は全体に表示するとかえって見辛いので、表示しない。\r\n        if (this.hasFlags(UIElementFlags.IsScene))\r\n            return undefined;\r\n        if (true) {\r\n            if (!this._debugBitmap) {\r\n                this._debugBitmap = new Bitmap(this._combinedVisualRect.width, this._combinedVisualRect.height);\r\n            }\r\n            if (!this._debugSprite) {\r\n                this._debugSprite = new Sprite(this._debugBitmap);\r\n                this._debugBitmap.fillRect(0, 0, this._debugBitmap.width, this._debugBitmap.height, \"#FFFF0022\");\r\n                this._debugBitmap.strokeRect(0, 0, this._debugBitmap.width, this._debugBitmap.height, \"#FF0000FF\");\r\n                context.addSprite2(UIContext_1.UISpiteLayer.Overlay, this._debugSprite);\r\n            }\r\n            this._debugSprite.x = this._combinedVisualRect.x;\r\n            this._debugSprite.y = this._combinedVisualRect.y;\r\n            return this._debugSprite;\r\n        }\r\n    }\r\n    updateVisualContentsHierarchical(context) {\r\n        this.updateVisualContents(context);\r\n        for (const child of this._visualChildren) {\r\n            child.updateVisualContentsHierarchical(context);\r\n        }\r\n    }\r\n    updateVisualContents(context) {\r\n        if (this.isInvalidate(UIInvalidateFlags.VisualContent)) {\r\n            this.unsetInvalidate(UIInvalidateFlags.VisualContent);\r\n            if (this.actualStyle.background) {\r\n                this.setFlags(UIElementFlags.RequireBackgroundSprite);\r\n            }\r\n            this.onRefreshVisual(context);\r\n            if (this.actualStyle.background) {\r\n                const sprite = this.prepareBackgroundSprite(context);\r\n                const bitmap = sprite.bitmap;\r\n                (0, Common_1.assert)(bitmap);\r\n                //bitmap.fillRect(0, 0, bitmap.width, bitmap.height, this.actualStyle.background);\r\n            }\r\n            this.prepareDebugSprite(context);\r\n        }\r\n    }\r\n    onRefreshVisual(context) {\r\n    }\r\n    // public actualWidth(): number {\r\n    //     return this._actualWidth;\r\n    // }\r\n    // public actualHeight(): number {\r\n    //     return this._actualHeight;\r\n    // }\r\n    draw(context) {\r\n    }\r\n}\r\nexports.VUIElement = VUIElement;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/UIElement.ts?");

/***/ }),

/***/ "./ts/ui/UIElementFactory.ts":
/*!***********************************!*\
  !*** ./ts/ui/UIElementFactory.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIElementFactory = void 0;\r\nconst DCommandWindow_1 = __webpack_require__(/*! ts/design/DCommandWindow */ \"./ts/design/DCommandWindow.ts\");\r\nconst DIcon_1 = __webpack_require__(/*! ts/design/DIcon */ \"./ts/design/DIcon.ts\");\r\nconst DImage_1 = __webpack_require__(/*! ts/design/DImage */ \"./ts/design/DImage.ts\");\r\nconst DListItem_1 = __webpack_require__(/*! ts/design/DListItem */ \"./ts/design/DListItem.ts\");\r\nconst DText_1 = __webpack_require__(/*! ts/design/DText */ \"./ts/design/DText.ts\");\r\nconst DWindow_1 = __webpack_require__(/*! ts/design/DWindow */ \"./ts/design/DWindow.ts\");\r\nconst DAccordionLayout_1 = __webpack_require__(/*! ts/design/layout/DAccordionLayout */ \"./ts/design/layout/DAccordionLayout.ts\");\r\nconst DGridLayout_1 = __webpack_require__(/*! ts/design/layout/DGridLayout */ \"./ts/design/layout/DGridLayout.ts\");\r\nconst DStackLayout_1 = __webpack_require__(/*! ts/design/layout/DStackLayout */ \"./ts/design/layout/DStackLayout.ts\");\r\nconst SceneDesign_1 = __webpack_require__(/*! ts/design/SceneDesign */ \"./ts/design/SceneDesign.ts\");\r\nconst UIImage_1 = __webpack_require__(/*! ./components/UIImage */ \"./ts/ui/components/UIImage.ts\");\r\nconst UIIon_1 = __webpack_require__(/*! ./components/UIIon */ \"./ts/ui/components/UIIon.ts\");\r\nconst UIListItem_1 = __webpack_require__(/*! ./components/UIListItem */ \"./ts/ui/components/UIListItem.ts\");\r\nconst UIText_1 = __webpack_require__(/*! ./components/UIText */ \"./ts/ui/components/UIText.ts\");\r\nconst UIAccordionLayout_1 = __webpack_require__(/*! ./layout/UIAccordionLayout */ \"./ts/ui/layout/UIAccordionLayout.ts\");\r\nconst UIGridLayout_1 = __webpack_require__(/*! ./layout/UIGridLayout */ \"./ts/ui/layout/UIGridLayout.ts\");\r\nconst UIStackLayout_1 = __webpack_require__(/*! ./layout/UIStackLayout */ \"./ts/ui/layout/UIStackLayout.ts\");\r\nconst UIScene_1 = __webpack_require__(/*! ./UIScene */ \"./ts/ui/UIScene.ts\");\r\nconst UICommandWindow_1 = __webpack_require__(/*! ./windows/UICommandWindow */ \"./ts/ui/windows/UICommandWindow.ts\");\r\nconst UIWindow_1 = __webpack_require__(/*! ./windows/UIWindow */ \"./ts/ui/windows/UIWindow.ts\");\r\nclass UIElementFactory {\r\n    createUIElement(design) {\r\n        if (design instanceof DText_1.DText) {\r\n            return new UIText_1.UIText(design);\r\n        }\r\n        else if (design instanceof DImage_1.DImage) {\r\n            return new UIImage_1.UIImage(design);\r\n        }\r\n        else if (design instanceof DIcon_1.DIcon) {\r\n            return new UIIon_1.UIICon(design);\r\n        }\r\n        else if (design instanceof DListItem_1.DListItem) {\r\n            return new UIListItem_1.UIListItem(design);\r\n        }\r\n        else if (design instanceof DStackLayout_1.DStackLayout) {\r\n            return new UIStackLayout_1.UIStackLayout(design);\r\n        }\r\n        else if (design instanceof DGridLayout_1.DGridLayout) {\r\n            return new UIGridLayout_1.UIGridLayout(design);\r\n        }\r\n        else if (design instanceof DAccordionLayout_1.DAccordionLayout) {\r\n            return new UIAccordionLayout_1.UIAccordionLayout(design);\r\n        }\r\n        else if (design instanceof DCommandWindow_1.DCommandWindow) {\r\n            return new UICommandWindow_1.UICommandWindow(design);\r\n        }\r\n        else if (design instanceof DWindow_1.DWindow) {\r\n            return new UIWindow_1.UIWindow(design);\r\n        }\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    instantiateScene(design) {\r\n        if (design) {\r\n            const scene = new UIScene_1.UIScene(design);\r\n            for (const child of design.contents) {\r\n                scene.addLogicalChild(this.instantiateElement(child));\r\n            }\r\n            return scene;\r\n        }\r\n        else {\r\n            const design = new SceneDesign_1.SceneDesign({});\r\n            const scene = new UIScene_1.UIScene(design);\r\n            return scene;\r\n        }\r\n    }\r\n    instantiateElement(design) {\r\n        const element = this.createUIElement(design);\r\n        for (const child of design.contents) {\r\n            element.addLogicalChild(this.instantiateElement(child));\r\n        }\r\n        return element;\r\n    }\r\n}\r\nexports.UIElementFactory = UIElementFactory;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/UIElementFactory.ts?");

/***/ }),

/***/ "./ts/ui/UIScene.ts":
/*!**************************!*\
  !*** ./ts/ui/UIScene.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIScene = void 0;\r\nconst Common_1 = __webpack_require__(/*! ts/core/Common */ \"./ts/core/Common.ts\");\r\nconst FlexWindowsManager_1 = __webpack_require__(/*! ts/core/FlexWindowsManager */ \"./ts/core/FlexWindowsManager.ts\");\r\nconst UIContainer_1 = __webpack_require__(/*! ./UIContainer */ \"./ts/ui/UIContainer.ts\");\r\nconst UIContext_1 = __webpack_require__(/*! ./UIContext */ \"./ts/ui/UIContext.ts\");\r\nconst UIElement_1 = __webpack_require__(/*! ./UIElement */ \"./ts/ui/UIElement.ts\");\r\nconst UIWindow_1 = __webpack_require__(/*! ./windows/UIWindow */ \"./ts/ui/windows/UIWindow.ts\");\r\nconst UIWindowBase_1 = __webpack_require__(/*! ./windows/UIWindowBase */ \"./ts/ui/windows/UIWindowBase.ts\");\r\nclass UIScene extends UIContainer_1.VUIContainer {\r\n    constructor(design) {\r\n        super(design);\r\n        this.attachedExistingWindows = [];\r\n        this.setFlags(UIElement_1.UIElementFlags.IsScene);\r\n        this._context = new UIContext_1.UIContext(this);\r\n    }\r\n    get owner() {\r\n        (0, Common_1.assert)(this._owner);\r\n        return this._owner;\r\n    }\r\n    get context() {\r\n        return this._context;\r\n    }\r\n    attachRmmzScene(owner) {\r\n        this._owner = owner;\r\n    }\r\n    detachRmmzScene() {\r\n        this.dispose();\r\n        this._owner = undefined;\r\n    }\r\n    findPIXIContainer() {\r\n        if (this._owner) {\r\n            return this._owner;\r\n        }\r\n        return super.findPIXIContainer();\r\n    }\r\n    addLogicalChild(element) {\r\n        super.addLogicalChild(element);\r\n        return element;\r\n    }\r\n    getRmmzWindowInitialRect(className) {\r\n        return undefined;\r\n    }\r\n    /** RMMZ コアスクリプト側で new された Window を論理的な子要素として管理下に入れる */\r\n    attachRmmzWindowIfNeeded(window) {\r\n        if (window._flexUIWindow)\r\n            return;\r\n        const element = this.findLogicalChildByClass(window.constructor.name);\r\n        if (element instanceof UIWindowBase_1.UIWindowBase) {\r\n            element.attachRmmzWindow(window);\r\n            this.attachedExistingWindows.push(window);\r\n            return;\r\n        }\r\n        const design = FlexWindowsManager_1.FlexWindowsManager.instance.findWindowDesign(window);\r\n        if (design) {\r\n            const element = FlexWindowsManager_1.FlexWindowsManager.instance.uiElementFactory.instantiateElement(design);\r\n            element.attachRmmzWindow(window);\r\n            this.addLogicalChild(element);\r\n            this.attachedExistingWindows.push(window);\r\n            return;\r\n        }\r\n    }\r\n    onSceneCreate() {\r\n        var _a;\r\n        for (const window of this.attachedExistingWindows) {\r\n            (_a = window._flexUIWindow) === null || _a === void 0 ? void 0 : _a.onSyncFromRmmzWindowContents();\r\n        }\r\n        this.traverseVisualChildren(child => {\r\n            if (child instanceof UIWindow_1.UIWindow) {\r\n                child.createRmmzWindowIfNeeded(this);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.UIScene = UIScene;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/UIScene.ts?");

/***/ }),

/***/ "./ts/ui/UIStyle.ts":
/*!**************************!*\
  !*** ./ts/ui/UIStyle.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIStyle = void 0;\r\nconst DStyle_1 = __webpack_require__(/*! ts/design/DStyle */ \"./ts/design/DStyle.ts\");\r\nclass UIStyle {\r\n    constructor(data) {\r\n        this.data = data;\r\n        this.dirty = true;\r\n    }\r\n    get stateName() {\r\n        return this.data.props.state || \"\";\r\n    }\r\n    evaluate(context, self) {\r\n        if (!this.dirty)\r\n            return;\r\n        this.dirty = false;\r\n        const props = this.data.props;\r\n        if (props.marginLeft !== undefined) {\r\n            this.marginLeft = props.marginLeft;\r\n        }\r\n        if (props.marginTop !== undefined) {\r\n            this.marginTop = props.marginTop;\r\n        }\r\n        if (props.marginRight !== undefined) {\r\n            this.marginRight = props.marginRight;\r\n        }\r\n        if (props.marginBottom !== undefined) {\r\n            this.marginBottom = props.marginBottom;\r\n        }\r\n        if (props.paddingLeft !== undefined) {\r\n            this.paddingLeft = props.paddingLeft;\r\n        }\r\n        if (props.paddingTop !== undefined) {\r\n            this.paddingTop = props.paddingTop;\r\n        }\r\n        if (props.paddingRight !== undefined) {\r\n            this.paddingRight = props.paddingRight;\r\n        }\r\n        if (props.paddingBottom !== undefined) {\r\n            this.paddingBottom = props.paddingBottom;\r\n        }\r\n        if (this.data.props.rect) {\r\n            const rect = this.data.props.rect;\r\n            if (rect instanceof DStyle_1.DStyleScriptValue) {\r\n                const r = this.evalScript(rect.script, context, self);\r\n                if (r) {\r\n                    this.x = r.x;\r\n                    this.y = r.y;\r\n                    this.width = r.width;\r\n                    this.height = r.height;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\"not implemented\");\r\n            }\r\n        }\r\n        if (props.x !== undefined) {\r\n            this.x = props.x;\r\n        }\r\n        if (props.y !== undefined) {\r\n            this.y = props.y;\r\n        }\r\n        if (props.width !== undefined) {\r\n            this.width = props.width;\r\n        }\r\n        if (props.height !== undefined) {\r\n            this.height = props.height;\r\n        }\r\n        if (props.opacity !== undefined) {\r\n            this.opacity = props.opacity;\r\n        }\r\n        if (props.backOpacity !== undefined) {\r\n            this.backOpacity = props.backOpacity;\r\n        }\r\n        if (props.contentsOpacity !== undefined) {\r\n            this.contentsOpacity = props.contentsOpacity;\r\n        }\r\n        if (props.background !== undefined) {\r\n            this.background = props.background;\r\n        }\r\n        if (props.originX !== undefined) {\r\n            this.originX = props.originX;\r\n        }\r\n        if (props.originY !== undefined) {\r\n            this.originY = props.originY;\r\n        }\r\n        if (props.frameVisible !== undefined) {\r\n            this.frameVisible = props.frameVisible;\r\n        }\r\n    }\r\n    evalScript(script, content, self_) {\r\n        const scene = content.owner.owner;\r\n        const window = content.currentWindow;\r\n        //const self = self_.owner;\r\n        return eval(script);\r\n    }\r\n}\r\nexports.UIStyle = UIStyle;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/UIStyle.ts?");

/***/ }),

/***/ "./ts/ui/components/UICommandItem.ts":
/*!*******************************************!*\
  !*** ./ts/ui/components/UICommandItem.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UICommandItem = void 0;\r\nconst UISelectableItem_1 = __webpack_require__(/*! ./UISelectableItem */ \"./ts/ui/components/UISelectableItem.ts\");\r\nclass UICommandItem extends UISelectableItem_1.UISelectableItem {\r\n    constructor(design) {\r\n        super(design);\r\n        //this._design = design;\r\n        this.rmmzCommandIndex = 0;\r\n        // if (this._design.text !== undefined) {\r\n        //     const textDesign = new DText({text: this._design.text});\r\n        //     const text = new UIText(textDesign);\r\n        //     this.addLogicalChild(text);\r\n        // }\r\n    }\r\n}\r\nexports.UICommandItem = UICommandItem;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/components/UICommandItem.ts?");

/***/ }),

/***/ "./ts/ui/components/UIImage.ts":
/*!*************************************!*\
  !*** ./ts/ui/components/UIImage.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIImage = void 0;\r\nconst UIElement_1 = __webpack_require__(/*! ../UIElement */ \"./ts/ui/UIElement.ts\");\r\nconst UILayoutHelper_1 = __webpack_require__(/*! ../utils/UILayoutHelper */ \"./ts/ui/utils/UILayoutHelper.ts\");\r\nclass UIImage extends UIElement_1.VUIElement {\r\n    constructor(design) {\r\n        super(design);\r\n        this._bitmap = ImageManager.loadSystem(design.source);\r\n        this.actualStyle.defaultHorizontalAlignment = UILayoutHelper_1.UIHAlignment.Center;\r\n        this.actualStyle.defaultVerticalAlignment = UILayoutHelper_1.UIVAlignment.Center;\r\n        this.setFlags(UIElement_1.UIElementFlags.RequireForegroundSprite);\r\n    }\r\n    measureOverride(context, constraint) {\r\n        return { width: this._bitmap.width, height: this._bitmap.height };\r\n    }\r\n    onRefreshVisual(context) {\r\n        const sprite = this.prepareForegroundSprite(context, this._bitmap);\r\n    }\r\n}\r\nexports.UIImage = UIImage;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/components/UIImage.ts?");

/***/ }),

/***/ "./ts/ui/components/UIIon.ts":
/*!***********************************!*\
  !*** ./ts/ui/components/UIIon.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIICon = void 0;\r\nconst FlexWindowsManager_1 = __webpack_require__(/*! ts/core/FlexWindowsManager */ \"./ts/core/FlexWindowsManager.ts\");\r\nconst UIElement_1 = __webpack_require__(/*! ../UIElement */ \"./ts/ui/UIElement.ts\");\r\nclass UIICon extends UIElement_1.VUIElement {\r\n    constructor(design) {\r\n        super(design);\r\n        this.design = design;\r\n        if (design.props.src) {\r\n            this._bitmap = ImageManager.loadBitmap(FlexWindowsManager_1.FlexWindowsManager.instance.designDirectory, design.props.src);\r\n        }\r\n        else {\r\n            this._bitmap = ImageManager.loadSystem(\"IconSet\");\r\n        }\r\n        // this.actualStyle.defaultHorizontalAlignment = UIHAlignment.Center;\r\n        // this.actualStyle.defaultVerticalAlignment = UIVAlignment.Center;\r\n        this.setFlags(UIElement_1.UIElementFlags.RequireForegroundSprite);\r\n    }\r\n    measureOverride(context, constraint) {\r\n        return {\r\n            width: ImageManager.iconWidth,\r\n            height: ImageManager.iconHeight,\r\n        };\r\n    }\r\n    onRefreshVisual(context) {\r\n        const sprite = this.prepareForegroundSprite(context, this._bitmap);\r\n        // Window_Base.prototype.drawIcon\r\n        const pw = ImageManager.iconWidth;\r\n        const ph = ImageManager.iconHeight;\r\n        const sx = (this.design.iconIndex % 16) * pw;\r\n        const sy = Math.floor(this.design.iconIndex / 16) * ph;\r\n        sprite.setFrame(sx, sy, pw, ph);\r\n    }\r\n}\r\nexports.UIICon = UIICon;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/components/UIIon.ts?");

/***/ }),

/***/ "./ts/ui/components/UIListItem.ts":
/*!****************************************!*\
  !*** ./ts/ui/components/UIListItem.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIListItem = void 0;\r\nconst Common_1 = __webpack_require__(/*! ts/core/Common */ \"./ts/core/Common.ts\");\r\nconst DText_1 = __webpack_require__(/*! ts/design/DText */ \"./ts/design/DText.ts\");\r\nconst UIContainer_1 = __webpack_require__(/*! ../UIContainer */ \"./ts/ui/UIContainer.ts\");\r\nconst UIText_1 = __webpack_require__(/*! ./UIText */ \"./ts/ui/components/UIText.ts\");\r\nclass UIListItem extends UIContainer_1.VUIContainer {\r\n    constructor(design) {\r\n        super(design);\r\n        this._design = design;\r\n        this.rmmzCommandIndex = 0;\r\n        if (this._design.text !== undefined) {\r\n            const textDesign = new DText_1.DText({ text: this._design.text });\r\n            const text = new UIText_1.UIText(textDesign);\r\n            this.addLogicalChild(text);\r\n        }\r\n    }\r\n    arrangeOverride(context, borderBoxSize) {\r\n        const window = context.currentWindow;\r\n        (0, Common_1.assert)(window);\r\n        for (const child of this.contentChildren()) {\r\n            const rect = window.itemLineRect(this.itemIndex);\r\n            child.arrange(context, rect);\r\n        }\r\n        return borderBoxSize;\r\n    }\r\n}\r\nexports.UIListItem = UIListItem;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/components/UIListItem.ts?");

/***/ }),

/***/ "./ts/ui/components/UISelectableItem.ts":
/*!**********************************************!*\
  !*** ./ts/ui/components/UISelectableItem.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UISelectableItem = void 0;\r\nconst UIContainer_1 = __webpack_require__(/*! ../UIContainer */ \"./ts/ui/UIContainer.ts\");\r\nclass UISelectableItem extends UIContainer_1.VUIContainer {\r\n    constructor(design) {\r\n        super(design);\r\n        this._design = design;\r\n        this.rmmzCommandIndex = 0;\r\n        // if (this._design.text !== undefined) {\r\n        //     const textDesign = new DText({text: this._design.text});\r\n        //     const text = new UIText(textDesign);\r\n        //     this.addLogicalChild(text);\r\n        // }\r\n    }\r\n}\r\nexports.UISelectableItem = UISelectableItem;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/components/UISelectableItem.ts?");

/***/ }),

/***/ "./ts/ui/components/UIText.ts":
/*!************************************!*\
  !*** ./ts/ui/components/UIText.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIText = void 0;\r\nconst Common_1 = __webpack_require__(/*! ts/core/Common */ \"./ts/core/Common.ts\");\r\nconst UIElement_1 = __webpack_require__(/*! ../UIElement */ \"./ts/ui/UIElement.ts\");\r\nconst UILayoutHelper_1 = __webpack_require__(/*! ../utils/UILayoutHelper */ \"./ts/ui/utils/UILayoutHelper.ts\");\r\nclass UIText extends UIElement_1.VUIElement {\r\n    // private _bitmap: Bitmap | undefined;\r\n    // private _sprite: Sprite | undefined;\r\n    constructor(design) {\r\n        super(design);\r\n        this.design = design;\r\n        this._text = \"\";\r\n        this.actualStyle.defaultHorizontalAlignment = UILayoutHelper_1.UIHAlignment.Center;\r\n        this.actualStyle.defaultVerticalAlignment = UILayoutHelper_1.UIVAlignment.Center;\r\n        this.setFlags(UIElement_1.UIElementFlags.RequireForegroundSprite);\r\n    }\r\n    // private destroyResource(): void {\r\n    //     if (this._bitmap) {\r\n    //         this._bitmap.destroy();\r\n    //         this._bitmap = undefined;\r\n    //     }\r\n    //     if (this._sprite) {\r\n    //         this._sprite.destroy();\r\n    //         this._sprite = undefined;\r\n    //     }\r\n    // }\r\n    setText(value) {\r\n        this._text = value;\r\n        return this;\r\n    }\r\n    setColor(value) {\r\n        this._color = value;\r\n        return this;\r\n    }\r\n    getItemSize(rmmzWindow) {\r\n        if (rmmzWindow instanceof Window_Selectable) {\r\n            // Window_Selectable で使う場合、高さは lineHeight() ではなく itemHeight() を使う。\r\n            // こうしないと、 Window のサイズが未指定(子要素のサイズに合わせる) ときに、\r\n            // 最終的な Client サイズに対してサイズが合わず、スクロールカーソルが出てしまう。\r\n            const size = {\r\n                width: rmmzWindow.textWidth(this._text) + (rmmzWindow.itemPadding() * 2),\r\n                height: rmmzWindow.itemHeight()\r\n            };\r\n            return size;\r\n        }\r\n        else {\r\n            const rect = {\r\n                x: 0,\r\n                y: 0,\r\n                width: rmmzWindow.textWidth(this._text),\r\n                //width: metrics.width,\r\n                height: rmmzWindow.lineHeight()\r\n            };\r\n            return rect;\r\n        }\r\n    }\r\n    getItemLineOffset(rmmzWindow) {\r\n        if (rmmzWindow instanceof Window_Selectable) {\r\n            // RMMZ の Item の描画仕様に合わせてみる。\r\n            // こうしなくても動くが、テキストが上寄りになったり、微妙にレイアウトがきれいにならない。\r\n            const size = this.getItemSize(rmmzWindow);\r\n            const offset = {\r\n                x: rmmzWindow.itemPadding(),\r\n                y: (size.height - rmmzWindow.lineHeight()) / 2\r\n            };\r\n            return offset;\r\n        }\r\n        else {\r\n            const offset = {\r\n                x: 0,\r\n                y: 0\r\n            };\r\n            return offset;\r\n        }\r\n    }\r\n    onStyleUpdated(context) {\r\n        this._text = context.evaluateStyleValueAsString(this, this.design.props.text);\r\n    }\r\n    measureOverride(context, constraint) {\r\n        //const size = context.currentWindow.textSizeEx(this._text);\r\n        context.currentWindow.resetFontSettings();\r\n        // const wi = context.currentWindow.textWidth(this._text);\r\n        // const metrics = context.currentWindow.contents.context.measureText(this._text);\r\n        const rmmzWindow = context.currentWindow;\r\n        return this.getItemSize(rmmzWindow);\r\n        // if (rmmzWindow instanceof Window_Selectable) {\r\n        //     console.log(\"Window_Selectable!!\");\r\n        // }\r\n        // else {\r\n        //     const size: VUISize = {\r\n        //         width: rmmzWindow.textWidth(this._text),\r\n        //         //width: metrics.width,\r\n        //         height: rmmzWindow.lineHeight() };\r\n        //     // height は metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent でも取得できるが、\r\n        //     // フォントによっては見切れてしまうことがある。\r\n        //     // やむをえず、やや大きめにはなるが確実な lineHeight を使う。\r\n        //     const outer = this.calcContentOuter();\r\n        //     //this.setDesiredSize(size.width + outer.left + outer.right, size.height + outer.top + outer.bottom);\r\n        //     return size;\r\n        // }\r\n    }\r\n    onRefreshVisual(context) {\r\n        const sprite = this.prepareForegroundSprite(context, undefined);\r\n        const bitmap = sprite.bitmap;\r\n        (0, Common_1.assert)(bitmap);\r\n        bitmap.clear();\r\n        const rmmzWindow = context.currentWindow;\r\n        (0, Common_1.assert)(rmmzWindow instanceof Window_Selectable);\r\n        const oldContents = context.currentWindow.contents;\r\n        context.currentWindow.contents = bitmap;\r\n        //const rect = this.getItemRect(rmmzWindow);\r\n        // const padding = this.itemPadding();\r\n        // rect.x += padding;\r\n        // // Window_Selectable.prototype.itemLineRect\r\n        // let y = 0;\r\n        // const padding = (rect.height - rmmzWindow.lineHeight()) / 2;\r\n        // y += padding;\r\n        const offset = this.getItemLineOffset(rmmzWindow);\r\n        context.currentWindow.resetFontSettings();\r\n        //bitmap.drawText(this._text, 0, 0, bitmap.width, bitmap.height, \"center\");\r\n        context.currentWindow.drawTextEx(this._text, offset.x, offset.y, bitmap.width);\r\n        context.currentWindow.contents = oldContents;\r\n    }\r\n    draw(context) {\r\n        //console.log(\"draw UIText\", this);\r\n        // const window = context.currentWindow;\r\n        // if (this.actualStyle.opacity > 0.0) {\r\n        //     const rect = this.actualRect();\r\n        //     if (this._color) {\r\n        //         window.changeTextColor(this._color);\r\n        //     }\r\n        //     else {\r\n        //         window.resetTextColor();\r\n        //     }\r\n        //     window.contents.paintOpacity = this.actualStyle.opacity * 255;\r\n        //     //window.drawText(this._text, rect.x, rect.y, rect.width, \"left\");\r\n        //     window.drawTextEx(this._text, rect.x, rect.y, rect.width);\r\n        // }\r\n    }\r\n}\r\nexports.UIText = UIText;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/components/UIText.ts?");

/***/ }),

/***/ "./ts/ui/layout/UIAccordionLayout.ts":
/*!*******************************************!*\
  !*** ./ts/ui/layout/UIAccordionLayout.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIAccordionLayout = void 0;\r\nconst DStackLayout_1 = __webpack_require__(/*! ts/design/layout/DStackLayout */ \"./ts/design/layout/DStackLayout.ts\");\r\nconst UIElement_1 = __webpack_require__(/*! ../UIElement */ \"./ts/ui/UIElement.ts\");\r\nconst UILayoutHelper_1 = __webpack_require__(/*! ../utils/UILayoutHelper */ \"./ts/ui/utils/UILayoutHelper.ts\");\r\nclass UIAccordionLayout extends UIElement_1.VUIElement {\r\n    constructor(design) {\r\n        super(design);\r\n        this.design = design;\r\n        this.actualStyle.defaultHorizontalAlignment = UILayoutHelper_1.UIHAlignment.Stretch;\r\n        this.actualStyle.defaultVerticalAlignment = UILayoutHelper_1.UIVAlignment.Stretch;\r\n    }\r\n    addLogicalChild(element) {\r\n        this.addVisualChild(element);\r\n        return element;\r\n    }\r\n    measureOverride(context, constraint) {\r\n        const visualChildren = this.visualChildren;\r\n        const desiredSize = { width: 0, height: 0 };\r\n        for (let i = 0; i < visualChildren.length; i++) {\r\n            const child = visualChildren[i];\r\n            if (context.testLayoutEnabled(child)) {\r\n                child.measure(context, constraint);\r\n                const childDesiredSize = child.desiredSize;\r\n                if (this.design.orientation == DStackLayout_1.DOrientation.Horizontal || this.design.orientation == DStackLayout_1.DOrientation.ReverseHorizontal) {\r\n                    // 横に並べるときは、width の総和と height の最大値を取る\r\n                    desiredSize.width += childDesiredSize.width;\r\n                    desiredSize.height = Math.max(desiredSize.height, childDesiredSize.height);\r\n                }\r\n                else {\r\n                    // 縦に並べるときは、width の最大値と height の総和を取る\r\n                    desiredSize.width = Math.max(desiredSize.width, childDesiredSize.width);\r\n                    desiredSize.height += childDesiredSize.height;\r\n                }\r\n            }\r\n        }\r\n        // 基本的には親サイズ一杯に広げたい。\r\n        // desiredSize.width = Number.isFinite(constraint.width) ? constraint.width : desiredSize.width;\r\n        // desiredSize.height = Number.isFinite(constraint.height) ? constraint.height : desiredSize.height;\r\n        return desiredSize;\r\n    }\r\n    arrangeOverride(context, borderBoxSize) {\r\n        const scrollOffset = { x: 0, y: 0 };\r\n        const finalSlotRect = this.makeContentBoxSize(borderBoxSize);\r\n        const visualChildren = this.visualChildren;\r\n        // まずは first と last のサイズを求める\r\n        const firstChild = (visualChildren.length >= 1) ? visualChildren[0] : undefined;\r\n        const lastChild = (visualChildren.length >= 2) ? visualChildren[visualChildren.length - 1] : undefined;\r\n        const middleCount = Math.max(visualChildren.length - 2, 0);\r\n        let firstChildSize = { width: 0, height: 0 };\r\n        let lastChildSize = { width: 0, height: 0 };\r\n        if (firstChild) {\r\n            firstChildSize = {\r\n                width: Math.min(firstChild.desiredSize.width, finalSlotRect.width),\r\n                height: Math.min(firstChild.desiredSize.height, finalSlotRect.height)\r\n            };\r\n        }\r\n        if (lastChild) {\r\n            lastChildSize = {\r\n                width: Math.min(lastChild.desiredSize.width, finalSlotRect.width),\r\n                height: Math.min(lastChild.desiredSize.height, finalSlotRect.height)\r\n            };\r\n        }\r\n        // first と last 以外のサイズを求める\r\n        const middleSingleSize = {\r\n            width: Math.max(0, finalSlotRect.width - firstChildSize.width - lastChildSize.width) / middleCount,\r\n            height: Math.max(0, finalSlotRect.height - firstChildSize.height - lastChildSize.height) / middleCount,\r\n        };\r\n        const isHorizontal = (this.design.orientation == DStackLayout_1.DOrientation.Horizontal || this.design.orientation == DStackLayout_1.DOrientation.ReverseHorizontal);\r\n        let x = finalSlotRect.x - scrollOffset.x;\r\n        let y = finalSlotRect.y - scrollOffset.y;\r\n        const advanceCurrentPos = (rect) => {\r\n            if (this.design.orientation == DStackLayout_1.DOrientation.Horizontal) {\r\n                x += rect.width;\r\n            }\r\n            else if (this.design.orientation == DStackLayout_1.DOrientation.Vertical) {\r\n                y += rect.height;\r\n            }\r\n            else {\r\n                throw new Error(\"Invalid orientation\");\r\n            }\r\n        };\r\n        // First child.\r\n        if (firstChild) {\r\n            if (context.testLayoutEnabled(firstChild)) {\r\n                const rect = {\r\n                    x: x,\r\n                    y: y,\r\n                    width: (isHorizontal) ? firstChildSize.width : finalSlotRect.width,\r\n                    height: (isHorizontal) ? finalSlotRect.height : firstChildSize.height,\r\n                };\r\n                firstChild.arrange(context, rect);\r\n                advanceCurrentPos(rect);\r\n            }\r\n        }\r\n        // Middle children.\r\n        for (let i = 1; i < visualChildren.length - 1; i++) {\r\n            const child = visualChildren[i];\r\n            if (context.testLayoutEnabled(child)) {\r\n                const rect = {\r\n                    x: x,\r\n                    y: y,\r\n                    width: (isHorizontal) ? middleSingleSize.width : finalSlotRect.width,\r\n                    height: (isHorizontal) ? finalSlotRect.height : middleSingleSize.height,\r\n                };\r\n                child.arrange(context, rect);\r\n                advanceCurrentPos(rect);\r\n            }\r\n        }\r\n        // Last child.\r\n        if (lastChild) {\r\n            if (context.testLayoutEnabled(lastChild)) {\r\n                const rect = {\r\n                    x: x,\r\n                    y: y,\r\n                    width: (isHorizontal) ? lastChildSize.width : finalSlotRect.width,\r\n                    height: (isHorizontal) ? finalSlotRect.height : lastChildSize.height,\r\n                };\r\n                if (this.design.orientation == DStackLayout_1.DOrientation.Horizontal || this.design.orientation == DStackLayout_1.DOrientation.ReverseHorizontal) {\r\n                    rect.x = finalSlotRect.width - lastChildSize.width;\r\n                }\r\n                else {\r\n                    rect.y = finalSlotRect.height - lastChildSize.height;\r\n                }\r\n                lastChild.arrange(context, rect);\r\n            }\r\n        }\r\n        return Object.assign({}, borderBoxSize);\r\n    }\r\n}\r\nexports.UIAccordionLayout = UIAccordionLayout;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/layout/UIAccordionLayout.ts?");

/***/ }),

/***/ "./ts/ui/layout/UIGridLayout.ts":
/*!**************************************!*\
  !*** ./ts/ui/layout/UIGridLayout.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIGridLayout = void 0;\r\nconst UIElement_1 = __webpack_require__(/*! ../UIElement */ \"./ts/ui/UIElement.ts\");\r\nclass UIGridLayout extends UIElement_1.VUIElement {\r\n    constructor(design) {\r\n        super(design);\r\n        this.design = design;\r\n    }\r\n}\r\nexports.UIGridLayout = UIGridLayout;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/layout/UIGridLayout.ts?");

/***/ }),

/***/ "./ts/ui/layout/UIStackLayout.ts":
/*!***************************************!*\
  !*** ./ts/ui/layout/UIStackLayout.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIStackLayout = void 0;\r\nconst DStackLayout_1 = __webpack_require__(/*! ts/design/layout/DStackLayout */ \"./ts/design/layout/DStackLayout.ts\");\r\nconst UIElement_1 = __webpack_require__(/*! ../UIElement */ \"./ts/ui/UIElement.ts\");\r\nclass UIStackLayout extends UIElement_1.VUIElement {\r\n    constructor(design) {\r\n        super(design);\r\n        this.design = design;\r\n    }\r\n    addLogicalChild(element) {\r\n        this.addVisualChild(element);\r\n        return element;\r\n    }\r\n    measureOverride(context, constraint) {\r\n        const size = Object.assign({}, constraint);\r\n        if (this.design.orientation == DStackLayout_1.DOrientation.Horizontal) {\r\n            // 横に並べる場合、幅の制限を設けない\r\n            size.width = Number.POSITIVE_INFINITY;\r\n        }\r\n        else {\r\n            // 縦に並べる場合、高さの制限を設けない\r\n            size.height = Number.POSITIVE_INFINITY;\r\n        }\r\n        const visualChildren = this.visualChildren;\r\n        const desiredSize = { width: 0, height: 0 };\r\n        for (let i = 0; i < visualChildren.length; i++) {\r\n            const child = visualChildren[i];\r\n            if (context.testLayoutEnabled(child)) {\r\n                child.measure(context, size);\r\n                const childDesiredSize = child.desiredSize;\r\n                if (this.design.orientation == DStackLayout_1.DOrientation.Horizontal || this.design.orientation == DStackLayout_1.DOrientation.ReverseHorizontal) {\r\n                    // 横に並べるときは、width の総和と height の最大値を取る\r\n                    desiredSize.width += childDesiredSize.width;\r\n                    desiredSize.height = Math.max(desiredSize.height, childDesiredSize.height);\r\n                }\r\n                else {\r\n                    // 縦に並べるときは、width の最大値と height の総和を取る\r\n                    desiredSize.width = Math.max(desiredSize.width, childDesiredSize.width);\r\n                    desiredSize.height += childDesiredSize.height;\r\n                }\r\n            }\r\n        }\r\n        return desiredSize;\r\n    }\r\n    arrangeOverride(context, borderBoxSize) {\r\n        const scrollOffset = { x: 0, y: 0 };\r\n        const finalSlotRect = this.makeContentBoxSize(borderBoxSize);\r\n        const childrenBoundSize = finalSlotRect;\r\n        let prevChildSize = 0;\r\n        let rPos = 0;\r\n        const childRect = { x: 0, y: 0, width: 0, height: 0 };\r\n        const visualChildren = this.visualChildren;\r\n        for (let i = 0; i < visualChildren.length; i++) {\r\n            const child = visualChildren[i];\r\n            if (context.testLayoutEnabled(child)) {\r\n                const childDesiredSize = child.desiredSize;\r\n                switch (this.design.orientation) {\r\n                    case DStackLayout_1.DOrientation.Horizontal:\r\n                        childRect.x += prevChildSize;\r\n                        prevChildSize = childDesiredSize.width;\r\n                        childRect.width = prevChildSize;\r\n                        childRect.height = childrenBoundSize.height;\r\n                        break;\r\n                    case DStackLayout_1.DOrientation.Vertical:\r\n                        childRect.y += prevChildSize;\r\n                        prevChildSize = childDesiredSize.height;\r\n                        childRect.width = childrenBoundSize.width;\r\n                        childRect.height = prevChildSize;\r\n                        break;\r\n                    case DStackLayout_1.DOrientation.ReverseHorizontal:\r\n                        prevChildSize = childDesiredSize.width;\r\n                        rPos -= prevChildSize;\r\n                        childRect.x = childrenBoundSize.width + rPos;\r\n                        childRect.width = prevChildSize;\r\n                        childRect.height = childrenBoundSize.height;\r\n                        break;\r\n                    case DStackLayout_1.DOrientation.ReverseVertical:\r\n                        prevChildSize = childDesiredSize.height;\r\n                        rPos -= prevChildSize;\r\n                        childRect.y = childrenBoundSize.height + rPos;\r\n                        childRect.width = childrenBoundSize.width;\r\n                        childRect.height = prevChildSize;\r\n                        break;\r\n                    default:\r\n                        throw new Error(\"Invalid orientation\");\r\n                }\r\n                // Lumino 特殊仕様。採集要素を Stretch で配置する。\r\n                const actual = { x: finalSlotRect.x + childRect.x, y: finalSlotRect.y + childRect.y, width: childRect.width, height: childRect.height };\r\n                if (this.design.props.lastStretch && i == visualChildren.length - 1) {\r\n                    actual.width = finalSlotRect.width - actual.x;\r\n                    actual.height = finalSlotRect.height - actual.y;\r\n                }\r\n                actual.x -= scrollOffset.x;\r\n                actual.y -= scrollOffset.y;\r\n                child.arrange(context, actual);\r\n            }\r\n        }\r\n        return Object.assign({}, finalSlotRect);\r\n    }\r\n}\r\nexports.UIStackLayout = UIStackLayout;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/layout/UIStackLayout.ts?");

/***/ }),

/***/ "./ts/ui/utils/UILayoutHelper.ts":
/*!***************************************!*\
  !*** ./ts/ui/utils/UILayoutHelper.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UILayoutHelper = exports.UIHAlignment = exports.UIVAlignment = void 0;\r\n/** 縦方向の表示位置を示します。*/\r\nvar UIVAlignment;\r\n(function (UIVAlignment) {\r\n    /** 子要素を、親のレイアウト スロットの中央に揃えて配置します。*/\r\n    UIVAlignment[UIVAlignment[\"Center\"] = 0] = \"Center\";\r\n    /** 子要素を、親のレイアウト スロットの上端に揃えて配置します。*/\r\n    UIVAlignment[UIVAlignment[\"Top\"] = 1] = \"Top\";\r\n    /** 子要素を、親のレイアウト スロットの下端に揃えて配置します。*/\r\n    UIVAlignment[UIVAlignment[\"Bottom\"] = 2] = \"Bottom\";\r\n    /** 子要素を、親のレイアウト スロット全体に引き伸ばします。*/\r\n    UIVAlignment[UIVAlignment[\"Stretch\"] = 3] = \"Stretch\";\r\n})(UIVAlignment = exports.UIVAlignment || (exports.UIVAlignment = {}));\r\n;\r\n/** 横方向の表示位置を示します。*/\r\nvar UIHAlignment;\r\n(function (UIHAlignment) {\r\n    /** 子要素を、親のレイアウト スロットの中央に揃えて配置します。*/\r\n    UIHAlignment[UIHAlignment[\"Center\"] = 0] = \"Center\";\r\n    /** 子要素を、親のレイアウト スロットの左側に揃えて配置します。*/\r\n    UIHAlignment[UIHAlignment[\"Left\"] = 1] = \"Left\";\r\n    /** 子要素を、親のレイアウト スロットの右側に揃えて配置します。*/\r\n    UIHAlignment[UIHAlignment[\"Right\"] = 2] = \"Right\";\r\n    /** 子要素を、親のレイアウト スロット全体に引き伸ばします。*/\r\n    UIHAlignment[UIHAlignment[\"Stretch\"] = 3] = \"Stretch\";\r\n})(UIHAlignment = exports.UIHAlignment || (exports.UIHAlignment = {}));\r\n;\r\nclass UILayoutHelper {\r\n    // widthNan : ユーザーが希望するサイズを指定しているか\r\n    static adjustHorizontalAlignment(areaWidth, desiredWidth, fixedWidthOrUndefined, align, outRect) {\r\n        switch (align) {\r\n            default:\r\n            case UIHAlignment.Center:\r\n                outRect.x = (areaWidth - desiredWidth) / 2;\r\n                outRect.width = desiredWidth;\r\n                break;\r\n            case UIHAlignment.Left:\r\n                outRect.x = 0;\r\n                outRect.width = desiredWidth;\r\n                break;\r\n            case UIHAlignment.Right:\r\n                outRect.x = areaWidth - desiredWidth;\r\n                outRect.width = desiredWidth;\r\n                break;\r\n            case UIHAlignment.Stretch:\r\n                if (fixedWidthOrUndefined === undefined) {\r\n                    outRect.x = 0;\r\n                    outRect.width = areaWidth;\r\n                }\r\n                else {\r\n                    outRect.x = (areaWidth - desiredWidth) / 2;\r\n                    outRect.width = fixedWidthOrUndefined;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    static adjustVerticalAlignment(areaHeight, desiredHeight, fixedHeightOrUndefined, align, outRect) {\r\n        switch (align) {\r\n            default:\r\n            case UIVAlignment.Center:\r\n                outRect.y = (areaHeight - desiredHeight) / 2;\r\n                outRect.height = desiredHeight;\r\n                break;\r\n            case UIVAlignment.Top:\r\n                outRect.y = 0;\r\n                outRect.height = desiredHeight;\r\n                break;\r\n            case UIVAlignment.Bottom:\r\n                outRect.y = areaHeight - desiredHeight;\r\n                outRect.height = desiredHeight;\r\n                break;\r\n            case UIVAlignment.Stretch:\r\n                if (fixedHeightOrUndefined === undefined) {\r\n                    outRect.y = 0;\r\n                    outRect.height = areaHeight;\r\n                }\r\n                else {\r\n                    outRect.y = (areaHeight - desiredHeight) / 2;\r\n                    outRect.height = fixedHeightOrUndefined;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n}\r\nexports.UILayoutHelper = UILayoutHelper;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/utils/UILayoutHelper.ts?");

/***/ }),

/***/ "./ts/ui/windows/UICommandWindow.ts":
/*!******************************************!*\
  !*** ./ts/ui/windows/UICommandWindow.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UICommandWindow = void 0;\r\nconst Common_1 = __webpack_require__(/*! ts/core/Common */ \"./ts/core/Common.ts\");\r\nconst DText_1 = __webpack_require__(/*! ts/design/DText */ \"./ts/design/DText.ts\");\r\nconst UICommandItem_1 = __webpack_require__(/*! ../components/UICommandItem */ \"./ts/ui/components/UICommandItem.ts\");\r\nconst UIText_1 = __webpack_require__(/*! ../components/UIText */ \"./ts/ui/components/UIText.ts\");\r\nconst UIWindow_1 = __webpack_require__(/*! ./UIWindow */ \"./ts/ui/windows/UIWindow.ts\");\r\nclass UICommandWindow extends UIWindow_1.UIWindow {\r\n    constructor(design) {\r\n        super(design);\r\n        this.design = design;\r\n    }\r\n    onSyncFromRmmzWindowContents() {\r\n        const rmmzWindow = this.rmmzWindow;\r\n        (0, Common_1.assert)(rmmzWindow);\r\n        this.clearSelectableItems();\r\n        for (let i = 0; i < rmmzWindow._list.length; i++) {\r\n            const command = rmmzWindow._list[i];\r\n            this.addCommandItem(command, i);\r\n        }\r\n    }\r\n    addCommandItem(data, index) {\r\n        const template = this.design.props.itemTemplate;\r\n        (0, Common_1.assert)(template);\r\n        const design = template.clone();\r\n        design.props.text = data.name;\r\n        design.props.symbol = data.symbol;\r\n        design.props.enabled = data.enabled;\r\n        const uiItem = new UICommandItem_1.UICommandItem(design);\r\n        if (design.contents.length > 0) {\r\n            throw new Error(\"not implemented\");\r\n        }\r\n        else {\r\n            const textDesign = new DText_1.DText({ text: data.name });\r\n            const text = new UIText_1.UIText(textDesign);\r\n            uiItem.addLogicalChild(text);\r\n        }\r\n        this.addSelectableItem(uiItem);\r\n    }\r\n}\r\nexports.UICommandWindow = UICommandWindow;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/windows/UICommandWindow.ts?");

/***/ }),

/***/ "./ts/ui/windows/UIWindow.ts":
/*!***********************************!*\
  !*** ./ts/ui/windows/UIWindow.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIWindow = void 0;\r\nconst UIWindowBase_1 = __webpack_require__(/*! ./UIWindowBase */ \"./ts/ui/windows/UIWindowBase.ts\");\r\n/**\r\n * Window_Base, Window_Scrollable, Window_Selectable に対応する UIElement.\r\n *\r\n * 上記まとめてこのクラスで扱っているのは、 RMMZ 標準の各種ウィンドウがほぼすべて Window_Selectable の派生であるため。\r\n * Content を自由に配置できるステータスウィンドウであっても Window_Selectable の派生として実装されている。\r\n * このため WPF でいうところの ItemsControl と ContentControl が統合された Control とみなして扱うほうが都合がよい。\r\n * あと、デザインファイルを編集するときも、「ステータスウィンドウなのにベースが Selectable？」となるのもちょっと気持ち悪い。\r\n *\r\n * Items のレイアウトは Window_Selectable のメソッドを利用して行われる。\r\n * WPF のように ItemsPane を自由に変更できると、Selection の変更をいい感じに制御するのが難しく、自分で専用の実装が必要になってしまう。\r\n * RMMZ 標準の動きとも異なるので、今はデフォルトに寄せたほうがいいだろう。\r\n */\r\nclass UIWindow extends UIWindowBase_1.UIWindowBase {\r\n    constructor(design) {\r\n        super(design);\r\n        this.design = design;\r\n        this._itemsChildren = [];\r\n        this.actualStyle.padding = $gameSystem.windowPadding();\r\n    }\r\n    dispose() {\r\n        this._itemsChildren.forEach((item) => item.dispose());\r\n        super.dispose();\r\n    }\r\n    onCreateRmmzWindow(rect) {\r\n        return new Window_Selectable(rect);\r\n    }\r\n    clearSelectableItems() {\r\n        if (this._itemsChildren.length == 0)\r\n            return;\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    addSelectableItem(item) {\r\n        this._itemsChildren.push(item);\r\n        item.setParent(this);\r\n        item.itemIndex = this._itemsChildren.length - 1;\r\n        this.addVisualChild(item);\r\n    }\r\n    // override updateStyle(context: UIContext): void {\r\n    //     for (const child of this._itemsChildren) {\r\n    //         child.updateStyle(context);\r\n    //     }\r\n    //     super.updateStyle(context);\r\n    // }\r\n    measureOverride(context, constraint) {\r\n        var _a, _b;\r\n        // Measure content.\r\n        let contentAreaSize = { width: 0, height: 0 };\r\n        for (const child of this.contentChildren()) {\r\n            child.measure(context, constraint);\r\n            contentAreaSize.width = Math.max(contentAreaSize.width, child.desiredSize.width);\r\n            contentAreaSize.height = Math.max(contentAreaSize.height, child.desiredSize.height);\r\n        }\r\n        // Measure items.\r\n        let itemsAreaSize = { width: 0, height: 0 };\r\n        const rmmzWindow = context.currentWindow;\r\n        if (rmmzWindow) {\r\n            for (const child of this._itemsChildren) {\r\n                const rect = rmmzWindow.itemRect(child.itemIndex);\r\n                child.measure(context, { width: rect.width, height: rect.height });\r\n                itemsAreaSize.width = Math.max(itemsAreaSize.width, child.desiredSize.width);\r\n                itemsAreaSize.height = Math.max(itemsAreaSize.height, child.desiredSize.height);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"Not implemented\");\r\n        }\r\n        // Make border size.\r\n        const contentsSize = {\r\n            width: Math.max(contentAreaSize.width, itemsAreaSize.width),\r\n            height: Math.max(contentAreaSize.height, itemsAreaSize.height)\r\n        };\r\n        const contentsBorderSize = this.makeBorderBoxSize(contentsSize);\r\n        // Measure self.\r\n        const selfSize = {\r\n            width: (_a = this.actualStyle.width) !== null && _a !== void 0 ? _a : 0,\r\n            height: (_b = this.actualStyle.height) !== null && _b !== void 0 ? _b : 0,\r\n        };\r\n        // Choose max.\r\n        //   RMMZWindow は box-sizing: border-box なので、makeBorderBoxSize() したコンテンツ領域と比較する必要がある。\r\n        const clientSize = {\r\n            width: Math.max(selfSize.width, contentsBorderSize.width),\r\n            height: Math.max(selfSize.height, contentsBorderSize.height)\r\n        };\r\n        return clientSize;\r\n        // assert(this.rmmzWindow);\r\n        // console.log(\"measureOverride\", this, this.actualStyle.width, this.actualStyle.height, this.rmmzWindow.width, this.rmmzWindow.height);\r\n        // const result = this.makeBorderBoxSize(clientSize);\r\n        // console.log(\"  result\", result);\r\n        // return result;\r\n    }\r\n    arrangeOverride(context, borderBoxSize) {\r\n        const clientBox = this.getLocalClientBox(borderBoxSize);\r\n        // Arrange content.\r\n        for (const child of this.contentChildren()) {\r\n            child.arrange(context, clientBox);\r\n        }\r\n        // if (this._content) {\r\n        //     const contentBox = { x: 0, y: 0, width: contentSize.width, height: contentSize.height };\r\n        //     this._content.arrange(context, contentBox);\r\n        // }\r\n        // Arrange items.\r\n        const rmmzWindow = context.currentWindow;\r\n        if (rmmzWindow) {\r\n            for (const child of this._itemsChildren) {\r\n                const rect = rmmzWindow.itemRect(child.itemIndex);\r\n                child.arrange(context, { x: clientBox.x + rect.x, y: clientBox.y + rect.y, width: rect.width, height: rect.height });\r\n            }\r\n            return borderBoxSize;\r\n        }\r\n        else {\r\n            throw new Error(\"Not implemented\");\r\n        }\r\n    }\r\n    // override updateCombinedVisualRect(context: UIContext, parentCombinedVisualRect: VUIRect): void {\r\n    //     this._combinedVisualRect.x = parentCombinedVisualRect.x + this._actualMarginBoxRect.x;\r\n    //     this._combinedVisualRect.y = parentCombinedVisualRect.y + this._actualMarginBoxRect.y;\r\n    //     this._combinedVisualRect.width = this._actualMarginBoxRect.width;\r\n    //     this._combinedVisualRect.height = this._actualMarginBoxRect.height;\r\n    // }\r\n    updateVisualContentsHierarchical(context) {\r\n        const oldWindow = context.changeWindow(this.rmmzWindow);\r\n        super.updateVisualContentsHierarchical(context);\r\n        context.changeWindow(oldWindow);\r\n    }\r\n}\r\nexports.UIWindow = UIWindow;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/windows/UIWindow.ts?");

/***/ }),

/***/ "./ts/ui/windows/UIWindowBase.ts":
/*!***************************************!*\
  !*** ./ts/ui/windows/UIWindowBase.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UIWindowBase = void 0;\r\nconst Common_1 = __webpack_require__(/*! ts/core/Common */ \"./ts/core/Common.ts\");\r\nconst FlexWindowsManager_1 = __webpack_require__(/*! ts/core/FlexWindowsManager */ \"./ts/core/FlexWindowsManager.ts\");\r\nconst UIContainer_1 = __webpack_require__(/*! ../UIContainer */ \"./ts/ui/UIContainer.ts\");\r\nconst UIElement_1 = __webpack_require__(/*! ../UIElement */ \"./ts/ui/UIElement.ts\");\r\nconst UILayoutHelper_1 = __webpack_require__(/*! ../utils/UILayoutHelper */ \"./ts/ui/utils/UILayoutHelper.ts\");\r\nclass UIWindowBase extends UIContainer_1.VUIContainer {\r\n    constructor(design) {\r\n        super(design);\r\n        this.design = design;\r\n        this.actualStyle.defaultHorizontalAlignment = UILayoutHelper_1.UIHAlignment.Left;\r\n        this.actualStyle.defaultVerticalAlignment = UILayoutHelper_1.UIVAlignment.Top;\r\n        this._defaultRect = { x: 0, y: 0, width: 0, height: 0 };\r\n    }\r\n    dispose() {\r\n        if (this._rmmzWindow) {\r\n            this._rmmzWindow._flexUIWindow = undefined;\r\n            this._rmmzWindow = undefined;\r\n        }\r\n        super.dispose();\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // Rmmz Window integration.\r\n    createRmmzWindowIfNeeded(scene) {\r\n        if (this._rmmzWindow)\r\n            return;\r\n        // この rect はダミー。\r\n        // onLayoutFixed() で正しい値に更新される。\r\n        const rect = new Rectangle(0, 0, 100, 100);\r\n        this._rmmzWindow = this.onCreateRmmzWindow(rect);\r\n        this._rmmzWindow._flexUIWindow = this;\r\n        scene.owner.addWindow(this._rmmzWindow);\r\n    }\r\n    onCreateRmmzWindow(rect) {\r\n        return new Window_Base(rect);\r\n    }\r\n    get rmmzWindow() {\r\n        (0, Common_1.assert)(this._rmmzWindow);\r\n        return this._rmmzWindow;\r\n    }\r\n    onSyncFromRmmzWindowContents() {\r\n    }\r\n    findPIXIContainer() {\r\n        if (this._rmmzWindow) {\r\n            return this._rmmzWindow;\r\n        }\r\n        return super.findPIXIContainer();\r\n    }\r\n    attachRmmzWindow(rmmzWindow) {\r\n        (0, Common_1.assert)(!rmmzWindow._flexUIWindow);\r\n        this._rmmzWindow = rmmzWindow;\r\n        rmmzWindow._flexUIWindow = this;\r\n        {\r\n            const rmmzWindowAny = rmmzWindow;\r\n            if (rmmzWindowAny.refresh) {\r\n                this._refreshFunc = rmmzWindowAny.refresh;\r\n                rmmzWindowAny.refresh = function () {\r\n                    if (this._flexUIWindow._refreshFunc)\r\n                        this._flexUIWindow._refreshFunc.call(this);\r\n                    this._flexUIWindow.onRefreshRmmzWindow();\r\n                };\r\n            }\r\n        }\r\n        // 必要であれば、rmmzWindow の配置情報を Style の初期値として取り出しておく。\r\n        // if (this.actualStyle.marginLeft !== undefined) this.actualStyle.marginLeft = rmmzWindow.x;\r\n        // if (this.actualStyle.marginTop !== undefined) this.actualStyle.marginTop = rmmzWindow.y;\r\n        // if (this.actualStyle.width !== undefined) this.actualStyle.width = rmmzWindow.width;\r\n        // if (this.actualStyle.height !== undefined) this.actualStyle.height = rmmzWindow.height;\r\n        if (!this.actualStyle.marginLeft)\r\n            this.actualStyle.marginLeft = rmmzWindow.x;\r\n        if (!this.actualStyle.marginTop)\r\n            this.actualStyle.marginTop = rmmzWindow.y;\r\n        if (!this.actualStyle.width)\r\n            this.actualStyle.width = rmmzWindow.width;\r\n        if (!this.actualStyle.height)\r\n            this.actualStyle.height = rmmzWindow.height;\r\n        if (this.design.props.windowskin) {\r\n            rmmzWindow.windowskin = ImageManager.loadBitmap(FlexWindowsManager_1.FlexWindowsManager.instance.designDirectory, this.design.props.windowskin);\r\n        }\r\n        if (this.design.props.visibleCoreContents !== undefined) {\r\n            rmmzWindow._contentsSprite.visible = this.design.props.visibleCoreContents;\r\n            rmmzWindow._contentsBackSprite.visible = this.design.props.visibleCoreContents;\r\n        }\r\n    }\r\n    onRefreshRmmzWindow() {\r\n        this.setInvalidate(UIElement_1.UIInvalidateFlags.All);\r\n        this.traverseVisualChildren((child) => {\r\n            child.setInvalidate(UIElement_1.UIInvalidateFlags.All);\r\n        });\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    _updateStyleHierarchical(context) {\r\n        const oldWindow = context.changeWindow(this._rmmzWindow);\r\n        super._updateStyleHierarchical(context);\r\n        context.changeWindow(oldWindow);\r\n    }\r\n    measure(context, size) {\r\n        if (context.layoutInitialing) {\r\n            // 子要素の masure 不要\r\n        }\r\n        else {\r\n            const oldWindow = context.changeWindow(this._rmmzWindow);\r\n            super.measure(context, size);\r\n            context.changeWindow(oldWindow);\r\n        }\r\n    }\r\n    measureOverride(context, constraint) {\r\n        var _a, _b;\r\n        const baseSize = super.measureOverride(context, constraint);\r\n        if (this._rmmzWindow) {\r\n            // this の desiredSize は、 Design で指定されたサイズがあればそれを使い、そうでなければ RMMZ デフォルトのを使う。\r\n            const size = {\r\n                width: (_a = this.actualStyle.width) !== null && _a !== void 0 ? _a : this._rmmzWindow.width,\r\n                height: (_b = this.actualStyle.height) !== null && _b !== void 0 ? _b : this._rmmzWindow.height,\r\n            };\r\n            return size;\r\n        }\r\n        else {\r\n            return baseSize;\r\n        }\r\n    }\r\n    arrange(context, finalArea) {\r\n        if (context.layoutInitialing) {\r\n            // 子要素の arrange 不要\r\n            this.setActualRect(finalArea);\r\n        }\r\n        else {\r\n            const oldWindow = context.changeWindow(this._rmmzWindow);\r\n            super.arrange(context, finalArea);\r\n            context.changeWindow(oldWindow);\r\n        }\r\n    }\r\n    draw(context) {\r\n        const oldWindow = context.changeWindow(this._rmmzWindow);\r\n        super.draw(context);\r\n        context.changeWindow(oldWindow);\r\n    }\r\n    updateCombinedVisualRectHierarchical(context, parentCombinedVisualRect) {\r\n        this.updateCombinedVisualRect(context, parentCombinedVisualRect);\r\n        // 以下子要素の原点は this の左上になるようにする。\r\n        const combinedVisualRect = this.getCombinedVisualRect();\r\n        const rect = { x: 0, y: 0, width: combinedVisualRect.width, height: combinedVisualRect.height };\r\n        for (const child of this.visualChildren) {\r\n            child.updateCombinedVisualRectHierarchical(context, rect);\r\n        }\r\n    }\r\n    // override updateCombinedVisualRect(context: UIContext, parentCombinedVisualRect: VUIRect): void {\r\n    //     super.updateCombinedVisualRect(context, parentCombinedVisualRect);\r\n    //     if (this._rmmzWindow) {\r\n    //         const srcRect = this.getCombinedVisualRect();\r\n    //         const rmmzWindow = this._rmmzWindow;\r\n    //         const newRect = {\r\n    //             x: 0,\r\n    //             y: 0,\r\n    //             width: srcRect.width,\r\n    //             height: srcRect.height,\r\n    //         };\r\n    //         this.setCombinedVisualRect(newRect);\r\n    //     }\r\n    // }\r\n    // protected updateCombinedVisualRectOverride(context: UIContext, parentCombinedVisualRect: VUIRect): VUIRect {\r\n    // }\r\n    // protected onSetRmmzRect(actualRect: VUIRect): void {\r\n    //     if (this._rmmzWindow) {\r\n    //         this._rmmzWindow.move(actualRect.x, actualRect.y, actualRect.width, actualRect.height);\r\n    //     }\r\n    // }\r\n    onLayoutFixed(context, combinedVisualRect) {\r\n        if (this._rmmzWindow) {\r\n            this._rmmzWindow.move(this.actualStyle.marginLeft + combinedVisualRect.x, this.actualStyle.marginTop + combinedVisualRect.y, combinedVisualRect.width, combinedVisualRect.height);\r\n        }\r\n    }\r\n}\r\nexports.UIWindowBase = UIWindowBase;\r\n\n\n//# sourceURL=webpack://FlexWindows/./ts/ui/windows/UIWindowBase.ts?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./ts/index.ts");
/******/ 	
/******/ })()
;